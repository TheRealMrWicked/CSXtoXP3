/*
	ADV管理クラス
*/

//タグハンドラの返値
var taghandler_end = 0;				//タグの取得を終了して、処理を吉里吉里に戻す
var taghandler_getcontinue = -1;	//続けてタグを取得する

var UPDATE_CG		= 0x01 << 0;
var UPDATE_BUSTUP	= 0x01 << 1;
var UPDATE_CUTIN	= 0x01 << 2;
var UPDATE_SOME		= 0x01 << 3;
var UPDATE_FOCUS	= 0x01 << 4;

//カメラ
var camera_fix  = 0;	//固定
var camera_auto = 1;	//自動追尾

//基本距離
var BG_RANGE_MAX = 128;

class ADVScreen extends Layer, SelectItemNotifyBase, SceneBase, ChainItemBase{
	var _scenario = "";
	var _label = "";
	var _scene = "";	//シーンタイトル
	var _name = "";
	var _mess = "";
	var _voice = "";
	var _pan = "";
	var _volume = "";
	//シナリオ制御
	var _scCtrl;
	var _orderList;
	var _orderIndex;
	var _end = false;	//このフラグが真ならば、トランジションが終了した時点でclose()する
	//ベースレイヤ
	var _baseOrder;
	//オブジェクト管理
	var _objList;
	//メッセージ管理
	var _msg;
	var _msgX, _msgY;	//表示位置、基本位置からの相対座標
	//カットイン
	var _cutin;
	var _cutinParam = %[file:"", pos:""];
	//シネマ
	var _cinema;
	//環境トーン
	var _envTone = TONE_DIC["normal"];

	//パラメータ(フラグ)管理
	var _param, _paramPrev;

	//各ファイル先頭でのセーブ情報を保持
	var _logSaveInfo = %[];
	//各ファイル終端での選択肢情報を保持
	var _logSelectEOF = %[];

	//ログ管理
	var _logName, _logMess, _logVoice, _logParam;

	//画面更新管理
	var _update;		//

	var _sceneType;

	var _sprTrans;		//トランジション用レイヤ
	var _eyeCatch;		//アイキャッチ用レイヤ

	var _envEffect = [];

	var _sprFlash;		//フラッシュ用レイヤ
	var _flashLeave;	//フラッシュ　復帰時間 .beginActivation(_flashLeave);

	var _eventCamera;		//イベント時、カメラ無効用レイヤ
	var _eventSceneSizeL;	//ＬサイズのイベントＣＧが表示されているかフラグ

	//メッセージフレームの非表示
	//trueにすると次のhitretがくるまで入力で再表示できない。
	var _advHide;

	//日付・ループ表示の制御
	//指定があるまで表示できない。
	var _advLoopHide, _advDateHide;

	//カメラ
	var _fCamera_move;		//
	var _camera_mode;		//カメラモード
	var _camera_pos;		//カメラ位置
							//x : 横軸
							//y : 縦軸
							//z : カメラ距離
	var _camera_move;		//カメラの移動ライン
	var _camera_move_start;	//カメラの移動開始時間
	var _camera_move_time_base;	//カメラの移動時間
	var _camera_move_time;		//

	//アクション
	var _fAction;
	var _actionTimeKeeper;
	var _actionList;
	var _actionWaitTarget;

	//スキップ
	var _requestStopSkip;	//次のHitret時にスキップを停止させる。

	//オート
	var _autoTimer;
	var _autoState;
	var _fPlayVoice;		//音声を指定があった（@talkに音声ファイルの指定があった）
	var _fPlayedVoice;		//実際に音声が再生されたか

	//選択肢
	var _startSelect;
	var _selectType;
	var _select;
	var _selectBase;
	var _selectHintIconImage;
	var _selectBtn;
	var _ret_select;		//選択された番号上から順
	var _ret_select_str;	//選択された文字列
	var _logSelect;			//選択肢で選んだ結果を記憶 セーブ復帰用
	var _stackSelect;		//選択肢のhitret位置を積み上げていく ジャンプ復帰用

	var _hitretWaitUntil;
	var _hitretState;		//hitret, startSelect状態(false: true:hitret待ち中)
							//trueでないときはＱセーブできない。
	var _hitretNum;			//hitret回数(startSelectもカウント) セーブ復帰用
	var _lastHitretID;
	var _quickSave;			//このhitretでクイックセーブした。

	var _fFont;				//次の1メッセージに限りフォントを変更する
	var _fontElm;
	var _fIgnoreKinsoku;	//次の1メッセージに限り禁則処理を無視する
	var _fFreeFormat;		//次の1メッセージをフリーフォーマットに。

	var _partMess;			//次のメッセージの指定文字の色を変更する
	var _ruby;				//次のメッセージの指定文字にルビを表示する

	var _face;				//フェイスの任意変更

	var _fBustupAutoPositioning;	//バストアップの自動位置調整
	var _fBustupRelateFlip;			//バストアップの位置関係の反転
	var _bustupRelateCustom;		//バストアップの位置関係の定義

	var _fMovie;			//ムービー再生中

	var _fHScene;			//HCGを表示中

	var _fRecollect;		//回想モードフラグ
	var _recollectStart, _recollectEnd;		//
	var _fPreviewMode;

	var _shift;

	//ロード処理用
	var _fLoad;
	var _hitretCnt;
	var _selectCnt;
	var _saveData;			//ロードしたセーブデータの保持

	//選択肢ジャンプ処理用
	var _jumpState;
	var _jumpParam = %[];
	//履歴のプレビュー作成用タグ保存
	var _previewTag = %[];

	//オートセーブ保存用
	var _autoSave;
	var _enableAutoSave = true;	//タイトルなどに戻る時にセーブさせるかどうか

	//クイックロード用受け渡し変数
	var _tempQLoadFile;

	//デバッグ用
	var _strSearch;			//サーチスキップ

	var AUTOSTATE_MESSAGE_END = 0x01;
	var AUTOSTATE_VOICE_END = 0x02;
	var AUTOSTATE_TRANSITION_END = 0x04;
	var AUTOSTATE_ALL_END = AUTOSTATE_MESSAGE_END | 
							AUTOSTATE_VOICE_END | 
							AUTOSTATE_TRANSITION_END;

	var CUTIN_X = WINDOW_WIDTH \ 2;
	var CUTIN_Y = WINDOW_HEIGHT \ 2 - 100;

	function ADVScreen(win, order=0, msgOrder=10, recollect=%[recollect:false, start:0, end:0], fPreviewMode=false){
		Layer(win, win.baseLayer);

		_scCtrl = new ScController(getHandlers());
		_scCtrl.loadMacro("macro.ks");

		_orderList = new Array();
		_orderIndex = 0;

		_fRecollect = GetElm(recollect.recollect, false);
		_recollectStart = GetElm(recollect.start, 0);
		_recollectEnd = GetElm(recollect.end, 0);
		_fPreviewMode = fPreviewMode;

		_objList = new Array();

		_baseOrder = order;

		hasImage = false;
		setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
		absolute = _baseOrder;
		hitType = htMask;
		hitThreshold = 0;

		_sprTrans = new Sprite(window, window.baseLayer);
		with(_sprTrans){
			.setImageSize(WINDOW_WIDTH, WINDOW_HEIGHT);
			.setSizeToImageSize();
			.absolute = _baseOrder + 1;
			.setTransitionCompleteCall(transitionComplete);
			.setActionCall(action);
		}

		_eyeCatch = null;

		var id = addADVObject("背景");
		with(_objList[id]){
			.kind = ADVOBJ_CG;
			._spr.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
			.setWorldPos(0, 0, BG_RANGE_MAX);
			.setBasePos(WINDOW_CENTER_X, WINDOW_CENTER_Y);
			.setCenter(WINDOW_CENTER_X, WINDOW_CENTER_Y);
			._spr.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, GetDefineColorA("black"));
			.absolute = ADVLAYER_BACK;
			.visible = true;
			.onPaint();
		}
		_eventCamera = new global.Sprite(window, this);
		with(_eventCamera){
			.setAffineOffset(0, 0);
			.hitThreshold = 256;
			.absolute = _objList[id].absolute+1;
		}
		_eventSceneSizeL = false;

		//メッセージエリア作成
		_msg = new MessageFrame(window, window.baseLayer, this);
		_msg.absolute = msgOrder;
		_msg.windowDepth((255 * CONFIG.windowDepth) \ 100);
		_msgX = 0;
		_msgY = 0;

		_param = new Parameter(PARAMETER_MAX);
		_paramPrev = new Parameter(PARAMETER_MAX);

		_logName = [];
		_logMess = [];
		_logVoice = [];
		_logParam = [];

		_advHide = true;

		//カメラ初期設定
		_fCamera_move = false;
		_camera_mode = camera_auto;
		_camera_pos = new Point(0, 0, -BG_RANGE_MAX);
		_camera_move = new D3Linear();
		_camera_move_start = 0;
		_camera_move_time_base = 500;
		_camera_move_time = 500;

		//アクション
		_fAction = false;
		_actionTimeKeeper = new TimeKeeper();
		_actionTimeKeeper.start();
		_actionList = new ActionList(this);
		_actionWaitTarget = null;

		_sprFlash = void;

		//スキップ
		_requestStopSkip = false;
		//オート
		_autoTimer = new Timer(onAutoCallback, "");
		_autoTimer.interval = CONFIG.autoSpeed + 1;
		_autoState = 0;
		_fPlayVoice = false;
		_fPlayedVoice = false;

		_select = [];
		_selectBtn = [];
		_selectBase = new SelectItemGroupSprite(win, this);
		with(_selectBase){
			.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
			.absolute = ADVLAYER_SELECT;
			.hitType = htMask;
			.hitThreshold = 0;
			.opacity = 0;
		}
		_logSelect = [];
		_stackSelect = [];

		_hitretState = false;
		_hitretNum = 0;

		//環境エフェクト
		_envEffect[ENVEFFECT_SNOW] = new EnvEffectSnow(win, this);
		_envEffect[ENVEFFECT_RAIN] = new EnvEffectRain(win, this);
		_envEffect[ENVEFFECT_BG_SCROLL] = new EnvEffectBgScroll(win, this);

		_update = 0;

		_msg.skip = _msg.auto = false;

		_fFont = false;
		_fontElm = new Dictionary();
		_fIgnoreKinsoku = false;
		_fFreeFormat = false;
		resetFontElm();

		_partMess = [];
		_ruby = [];

		_cinema = new CinemaStrap(win, this);
		_cinema.visible = true;

		_face = "";

		_fBustupAutoPositioning = true;
		_fBustupRelateFlip = false;
		_bustupRelateCustom = "";

		_strSearch = "";

		_fLoad = false;
		_saveData = null;

		_autoSave = new Savedata();

		_fMovie = false;
		_fHScene = false;

		_sceneType = SCENETYPE_NORMAL;

		if(!_fPreviewMode){
			VOICE = new SoundLayer(this);
			VOICE.volume = CONFIG.volVoice;
			BGV = new SoundLayer(this);
			BGV.volume = CONFIG.volBgv;

			window.addInputNotify(this);
		}

		visible = !fPreviewMode;
	}

	function finalize(){
		@if(__DEBUGMODE__)
			if(!_fPreviewMode)
				win.caption = global.GAME_CAPTION;
		@endif
		@if(__DEBUGMODE__)
			debug.applyFlagToDebug();
		@endif

		if(!_fRecollect) autoSave();

		if(!_fPreviewMode){
			window.removeInputNotify(this);
		}

		endSelect();

		if(IsStaffRoll()) StaffRollDelete();

		//ウィンドウ関係
		//ConfirmDelete();
		ConfigDelete();
		LoadSaveDelete();
		HistoryDelete();

		System.removeContinuousHandler(onActionCallback);

		invalidate _autoSave;

		InvalidateArray(_envEffect);
		if(_eyeCatch) invalidate _eyeCatch;
		invalidate _eventCamera;
		invalidate _cinema;
		invalidate _cutin;
		invalidate _sprFlash;
		invalidate _fontElm;
		InvalidateArray(_selectBtn);
		invalidate _selectBtn;
		invalidate _selectHintIconImage;
		invalidate _selectBase;
		invalidate _select;
		invalidate _camera_pos;
		invalidate _camera_move;
		invalidate _param;
		invalidate _paramPrev;
		invalidate _orderList;
		invalidate _msg;
		invalidate _sprTrans;
		invalidate _scCtrl;
		InvalidateArray(_objList);
		invalidate _objList;
		invalidate _logName;
		invalidate _logMess;
		invalidate _logVoice;
		invalidate _logParam;
		invalidate _actionList;
		invalidate _actionTimeKeeper;
		invalidate _previewTag;

		if(!_fPreviewMode){
			invalidate VOICE;
			VOICE = null;
			invalidate BGV;
			BGV = null;
		}

		global.Layer.finalize();
	}

	function who(){return "ADVScreen";}

	function start(name, label=""){
		if(!_fLoad){
			ParameterInit(_param);
			clearLog();

			cg(%[file:"BLACK"]);
			update(%[time:0]);
		}
		change(name, label);
	}

	function debugStart(name, label=""){
		if(!_fLoad){
			clearLog();
		}

		if(_startSelect) endSelect();
		cutin(%[hide:1]);
		cinema(%[type:0]);

		messageFrame(%[type:0]);

		hide(0, true);

		change(name, label);
	}

	function trigger(trig){
		_scCtrl.trigger(trig);
	}

	function rClick(){
		//ムービーが再生されていたらムービーをキャンセル
		if(IsPlayMovie() && _scCtrl.isTrigger("rclick")) onStopMovie();

		_scCtrl.trigger("rclick");
	}

	function click(){
		//カメラ移動待機中かつ、クリックキャンセル有効の時は
		//カメラ移動を完了させる。
		if(_scCtrl.isTrigger("movecamera_end") && _scCtrl.isTrigger("click")){
			flushMoveCamera();
		}

		//アクション待ち中かつ、クリックキャンセル有効の時は
		//アクションを完了させる。
		if(_scCtrl.isTrigger("action_end") && _scCtrl.isTrigger("click")){
			flushAction(_actionWaitTarget);
			_actionWaitTarget = null;
		}

		//フラッシュ待ち中、クリックキャンセル有効の時は
		//フラッシュを完了させる。
		if(_scCtrl.isTrigger("flash_end") && _scCtrl.isTrigger("click")){
			if(_sprFlash !== void){
				if(_sprFlash.isActivation()) _sprFlash.flushActivation();
			}
		}

		//ウィンドウ消去中かつ、waitトリガー待ちなしならクリックなし
		if(!isShow() && !_scCtrl.isTrigger("wait")) return;

		if(_msg.isPending() && CONFIG.messageFlushOnClick == 1){
		//メッセージ出力中
			_msg.flush();
			return;
		}

		if(_scCtrl.trigger("click")){
		//クリックトリガーが発生した
			_msg.hideBlink();

			//hitret中にクリックされた。
			//これ以降は_hitretStateがtrueになるまでＱセーブが抑制される。
			if(_hitretState){
				_hitretState = false;
			}

			if(CONFIG.voiceStopOnClick){
			//音声再生中にクリックが発生した場合は停止する
				_fPlayVoice = false;
				if(VOICE.isPlay()) StopVoice();
			}

			if(_face != "") _face = "";
		}

		//オートタイマーを解除しておく
		stopAutoTimer();
	}

	//メッセージ出力が完了した
	function onCompleteOutput(){
		checkAutoEvent(AUTOSTATE_MESSAGE_END);

		if(isSkip()){
		//スキップ中ならクリック
			click();
		}else if(isAuto()){
		//オート中ならクリックチェック
			if(checkAutoEvent() && _hitretState){ startAutoTimer(); }
		}
	}

	function startAutoTimer(){
		_autoTimer.interval = CONFIG.autoSpeed + 1;
		_autoTimer.enabled = true;
	}
	function stopAutoTimer(){
		if(!_autoTimer.enabled) return;
		_autoTimer.enabled = false;
	}

	//メッセージ出力完了、音声再生完了、トランジション完了
	//↑が全て完了した時、メッセージを進める準備が出来たことになる。
	function checkAutoEvent(state=0){
		_autoState |= state;
		if(_autoState == AUTOSTATE_ALL_END) return isAuto();
		return false;
	}

	function updateEnding(){
		_scCtrl.trigger("update");
	}

	//オーダーリスト
	function addOrderList(elm){
		var index = _orderList.count;
		_orderList[index] = new Dictionary();
		(Dictionary.assign incontextof _orderList[index])(elm);
	}
	function clearOrderList(){
		_orderList.clear();
		_orderIndex = 0;
	}
	function processOrder(list=[], elm=%[]){
		for(var i=0;i<list.count;i++){
			//timeをupdateで指定された値と同じにするかどうか・・・
			//if(elm.time !== void) list[i].time = elm.time;

			if(elm.flush !== void){
				if(elm.flush == 1) list[i].time = 0;
			}

			//タグ名を評価してファンクションを得る
			//var func = Scripts.eval("ADVScreen."+list[i].tagname);
			//func(list[i]);

			switch(list[i].tagname){
			case "cg":
				cg(list[i]);
				break;
			case "char":
				char(list[i]);
				break;
			case "clearchar":
				clearChar(list[i]);
				break;
			case "cutin":
				cutin(list[i]);
				break;
			case "movecamera":
				moveCamera(list[i]);
				break;
			case "move":
				move(list[i]);
				break;
			case "action":
				asyncAction(list[i]);
				break;
			case "stopaction":
				stopAsyncAction(list[i]);
				break;
			case "emotion":
				emotion(list[i]);
				break;
			case "stopemotion":
				stopEmotion(list[i]);
				break;
			case "tone":
				tone(list[i]);
				break;
			case "focus":
				focus(list[i]);
				break;
			case "update":
				update(list[i]);
				break;
			case "snow":
				envEffect(ENVEFFECT_SNOW, list[i]);
				break;
			case "rain":
				envEffect(ENVEFFECT_RAIN, list[i]);
				break;
			case "bgscroll":
				envEffect(ENVEFFECT_BG_SCROLL, list[i]);
				break;
			}
		}
		list.clear();
	}
	function separateOrder(srcList, preList, postList, lastList){
		for(var i=0;i<srcList.count;i++){
			switch(srcList[i].tagname){
			case "action" :
			case "focus" :
			case "tone" :
				var index = postList.count;
				postList[index] = %[];
				(Dictionary.assignStruct incontextof postList[index])(srcList[i]);
				break;
			case "emotion" :
			case "stopemotion" :
				var index = lastList.count;
				lastList[index] = %[];
				(Dictionary.assignStruct incontextof lastList[index])(srcList[i]);
				break;
			default:
				var index = preList.count;
				preList[index] = %[];
				(Dictionary.assignStruct incontextof preList[index])(srcList[i]);
				break;
			}
		}
	}

	//ADVObject管理
	function addADVObject(id){
	//オブジェクトリストの追加
		if(_objList.count > 0){
			for(var i=_objList.count-1;i>=0;i--){
				if(_objList[i].id == id){
					return i;
				}
			}
		}

		var i = _objList.count;
		_objList[i] = new ADVObject(window, this);
		_objList[i].adv = this;
		_objList[i].id = id;
		return i;
	}
	function removeADVObject(id){
	//オブジェクトリストの削除
		if(typeof id == "String"){
			for(var i=_objList.count-1;i>=0;i--){
				if(_objList[i].id == id){
					_objList[i].visible = false;
					if(_objList[i].isActivation()) _objList[i].stopActivation();
					if(_objList[i].isTransition()) _objList[i].stopTransition();
					if(_objList[i].isEmotion()) _objList[i].resetEmotion();
					invalidate _objList[i];
					_objList.erase(i);
					return 0;
				}
			}
			return -1;
		}else if(typeof id == "Integer"){
			for(var i=_objList.count-1;i>=0;i--){
				if(_objList[i].kind == id){
					_objList[i].visible = false;
					if(_objList[i].isActivation()) _objList[i].stopActivation();
					if(_objList[i].isTransition()) _objList[i].stopTransition();
					if(_objList[i].isEmotion()) _objList[i].resetEmotion();
					invalidate _objList[i];
					_objList.erase(i);
				}
			}
			return 0;
		}
	}
	function countADVObjCg(){
		cleaningADVObjectList();

		var cnt = 0;
		for(var i=_objList.count-1;i>=0;i--){
			if((_objList[i].kind == ADVOBJ_CG) &&
			   (_objList[i].destroy == ADVOBJ_DESTROY_NONE))
				cnt++;
		}
		return cnt;
	}
	function countADVObjBustup(ignoreFree=false){
		cleaningADVObjectList();

		var cnt = 0;
		for(var i=_objList.count-1;i>=0;i--){
			if((_objList[i].kind & ADVOBJ_BUSTUP) && (_objList[i].destroy == ADVOBJ_DESTROY_NONE)){
				if(ignoreFree && (_objList[i].kind & ADVOBJ_BUSTUP_FREE))
				//フリーバストアップはカウントから無視する
					continue;

				cnt++;
			}
		}
		return cnt;
	}
	//idからインデックスを取得する
	function getADVObjectIndex(id, fAll=false){
		cleaningADVObjectList();

		for(var i=0;i<_objList.count;i++){
			if(fAll){
				if(_objList[i].id == id){
					return i;
				}
			}else{
			//消滅予定のオブジェクトは無視する
				if((_objList[i].id == id)  &&
				   (_objList[i].destroy == ADVOBJ_DESTROY_NONE)){
					return i;
				}
			}
		}
		return -1;
	}
	//idからオブジェクトを取得する
	function getADVObjectObject(id, fAll=false){
		cleaningADVObjectList();

		for(var i=0;i<_objList.count;i++){
			if(fAll){
				if(_objList[i].id == id){
					return _objList[i];
				}
			}else{
			//消滅予定のオブジェクトは無視する
				if((_objList[i].id == id)  &&
				   (_objList[i].destroy == ADVOBJ_DESTROY_NONE)){
					return _objList[i];
				}
			}
		}
		return -1;
	}
	function cleaningADVObjectList(){
		for(var i=_objList.count-1;i>=0;i--){
			if(_objList[i].destroy == ADVOBJ_DESTROY_STANDBY){
				invalidate _objList[i];
				_objList.erase(i);
			}
		}
	}
	function sortADVObjectBustupRelate(){
	//リスト内のバストアップをrelateの昇順に並び替える

		//立ち位置関係が定義されていた場合は、定義に従ってrelateを変更する
		if(_bustupRelateCustom != ""){
			var idList = _bustupRelateCustom.split(",/");

			for(var i=0;i<_objList.count;i++){
				if(!(_objList[i].kind & ADVOBJ_BUSTUP)) continue;
				for(var r=0;r<idList.count;r++){
					if(_objList[i].id == idList[r]) _objList[i].relate = r;
				}
			}
		}

		var i, j;
		for(i=0;i<_objList.count-1;i++){
			if(_objList[i].kind & ADVOBJ_BUSTUP){
				for(j=i+1;j<_objList.count;j++){
					if(!_fBustupRelateFlip){
						if((_objList[j].kind & ADVOBJ_BUSTUP) &&
						   (_objList[i].relate > _objList[j].relate)){
							_objList[i] <-> _objList[j];
						}
					}else{
					//位置関係反転
						if((_objList[j].kind & ADVOBJ_BUSTUP) &&
						   (_objList[i].relate < _objList[j].relate)){
							_objList[i] <-> _objList[j];
						}
					}
				}
			}
		}
	}

	//カメラ操作
	function cameraMode(mode=camera_auto){
		_camera_mode = mode;
	}
	function moveCamera(elm=%[]){
		//カメラがアクション中なら止める
		if(_actionList.isAction(_camera_pos))
			_actionList.stopAction(_camera_pos);

		var scale = 2.0;

		cleaningADVObjectList();

		var pos;
		if(elm.pos === void)
			pos = new Point();
		else
			pos = PointStrToNum(elm.pos);
		if(elm.x !== void) pos.x = int elm.x;
		if(elm.y !== void) pos.y = int elm.y;
		if(elm.z !== void) pos.z = int elm.z;

		pos.z -= BG_RANGE_MAX;

		if(elm.id !== void){
			var obj = getADVObjectObject(elm.id);
			if(obj != -1){
				//対象のオブジェクトが有限アクション中なら止めること。
				var seq = _actionList.sequence(obj);
				if(_actionList.isAction(obj) && !seq.isLoop()) _actionList.stopAction(obj);

				pos.x = obj.getWorldPos().x / scale;
			}
		}
		pos.x *= scale;
		pos.y *= scale;

		var accel;
		if(elm.accel !== void)
			accel = elm.accel;
		else
			accel = 2;

		var time = 500;
		if(elm.time !== void)
			time = int(elm.time);
		if(isSkip())
			time = 0;
		if(CONFIG.screenEffect == 0)
			time = 0;
		if(CONFIG.eventCamera == 0 && _eventSceneSizeL)
			time = 0;

		_camera_move_time_base = time;

		//更新時間を演出速度設定で補正
		time = ReviceEffectSpeed(time);

		if(time == 0){
			@if(__DEBUGMODE__)
				debug.setCameraPos(int(pos.x/scale), int(pos.y/scale), pos.z+BG_RANGE_MAX);
			@endif

			_camera_pos.set(pos);

			putCameraViewObject(pos);
		}else{
			startAction();

			_fCamera_move = true;
			_camera_move.set(_camera_pos, pos, accel);
			_camera_move_start = _actionTimeKeeper.now();
			_camera_move_time = time;
		}
	}
	function putCameraViewObject(camera){
	//カメラに合わせてオブジェクトを配置
		for(var i=0;i<_objList.count;i++){
			with(_objList[i]){
				var kind = .info.kind;
				if(kind & ADVOBJ_SCREEN){
					.setPos(.wleft, .wtop);
				}else{
					var pos = worldToScreen(camera, .getWorldPos());
					if(.left != int(-pos.x) || .top != int(-pos.y))
						.setPos(-pos.x, -pos.y);
					if(.zoomx != pos.z)
						.zoom = pos.z;
				}
			}
		}
	}

	function onCameraCallback(now, fPutObj=true){
		var t;
		if(_camera_move_time == 0.0){
			t = 1.0;
		}else{
			//経過時間から進捗を計測
			t = (now - _camera_move_start) / real(_camera_move_time);
			if(t > 1.0) t = 1.0;
		}

		var pt = new Point();
		if(_fCamera_move){
			pt.set(_camera_move.pt(t));
		}else{
			pt.set(_camera_pos);
		}

		if(t >= 1.0){
			flushMoveCamera();
		}else{
			if(fPutObj) putCameraViewObject(pt);
			_camera_pos.set(pt);
		}

		@if(__DEBUGMODE__)
			var scale = 2.0;
			debug.setCameraPos(pt.x/scale, pt.y/scale, pt.z + BG_RANGE_MAX);
		@endif
	}
	function flushMoveCamera(fPutObj=true){
		var pt = new Point();
		if(_fCamera_move){
			pt.set(_camera_move.pt(1.0));
		}else{
			pt.set(_camera_pos);
		}
		if(fPutObj) putCameraViewObject(pt);
		_camera_pos.set(pt);
		_fCamera_move = false;

		_scCtrl.trigger("movecamera_end");

		@if(__DEBUGMODE__)
			var scale = 2.0;
			debug.setCameraPos(pt.x/scale, pt.y/scale);
		@endif
	}

	function eventCamera(f){
		var obj = getADVObjectObject("背景");
		obj.visible = true;
		_eventCamera.visible = false;

		if(!_eventSceneSizeL) return;

		if(f){
			var obj = getADVObjectObject("背景");
			obj.visible = true;

			_eventCamera.visible = false;
			_eventCamera.setImageSize(32, 32);
			_eventCamera.setSizeToImageSize();
		}else{
			var obj = getADVObjectObject("背景");
			obj.visible = false;

			with(_eventCamera){
				//背景オブジェクトの再現、、、ADVObjectのクローンコマンド作ったほうがいい
				var file = obj.file.substring(0, obj.file.length-1);
				try{
					AdvObjLoadImagesToLayer(_eventCamera, file);
					.setSizeToImageSize();

					if(obj._focus != 0) .doBoxBlur(obj._focus, obj._focus);
					if(obj._tone != "normal"){
						var tar = TONE_DIC[obj._tone];
						if(tar[3]) .doGrayScale();
						.adjustGamma(
							tar[0][0], tar[0][1], tar[0][2], 
							tar[1][0], tar[1][1], tar[1][2], 
							tar[2][0], tar[2][1], tar[2][2]
						);
					}
					if(obj._flipLR) .flipLR();
					if(obj._flipUD) .flipUD();
				}catch{
					.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
				}

				.visible = true;
			}
		}
	}

	//ワールド→スクリーン変換
	function worldToScreen(camera, wPos){
		var tempPos = new Point();

		var z = wPos.z - camera.z;
		tempPos.x = ((camera.x-wPos.x)*BG_RANGE_MAX) / z;
		tempPos.y = ((camera.y-wPos.y)*BG_RANGE_MAX) / z;
		tempPos.z = 100 * (wPos.z+BG_RANGE_MAX) / (wPos.z-camera.z);	//Zは拡大率で利用

		return tempPos;
	}
	//スクリーン→ワールド変換
	function screenToWorld(camera, pos){
		var tempPos = new Point();

		var z = pos.z-camera.z;
		tempPos.x = camera.x + (pos.x * z) / BG_RANGE_MAX;
		tempPos.y = camera.y + (pos.y * z) / BG_RANGE_MAX;
		tempPos.z = pos.z;
		return tempPos;
	}

	function onActionCallback(now){
		var time = _actionTimeKeeper.now();

		//カメラ移動
		if(_fCamera_move)
			onCameraCallback(time, false);

		//アクション
		if(_actionList.count != 0){
			_actionList.doAction(time);
		}

		//カメラに合わせてオブジェクト配置
		putCameraViewObject(_camera_pos);

		@if(__DEBUGMODE__)
			var scale = 2.0;
			debug.setCameraPos(int(_camera_pos.x/scale), int(_camera_pos.y/scale), _camera_pos.z+BG_RANGE_MAX);
		@endif

		if(!isActivity()){
			stopAction();
		}
	}

	function startAction(){
		System.addContinuousHandler(onActionCallback);
		_fAction = true;
	}
	function stopAction(){
		System.removeContinuousHandler(onActionCallback);
		_fAction = false;
	}
	function pauseAction(){
		if(!_fAction) return;

		_actionTimeKeeper.pause();
		System.removeContinuousHandler(onActionCallback);
	}
	function restartAction(){
		if(!_fAction) return;

		_actionTimeKeeper.restart();
		System.addContinuousHandler(onActionCallback);
	}
	function isActivity(){
	//活動中のオブジェクトはあるか？

		//アクションリストが１以上なら活動中
		if(_actionList.count != 0) return true;

		//カメラが移動中なら活動中
		if(_fCamera_move) return true;

		return false;
	}

	//ウィンドウクラスからの入力通知
	function onMouseDown(x, y, button, shift){
		_shift = shift;

		@if(__DEBUGMODE__)
			if(shift & ssShift) return;
		@endif

		if(button == mbLeft){
			if(!_msg.isShow() && _advHide == false){
				show(300);
			}else if(isSkip(true)){
				skip(false);	//スキップ解除
			}else{
				click();
			}
		}else if(button == mbRight){
			if(isAuto() || isSkip(true)){
				skip(false);	//スキップ解除
				auto(false);	//オート解除
			}else if(_advHide == false){
			//メッセージフレーム消去
				if(_msg.isActivation()){
				//フェード中ならなにもしない
				}else if(_msg.isShow() && _hitretState){
					hide(300);
				}else{
					show(300);
				}
			}
			rClick();
		}
	}

	function onMouseWheel(shift, delta, x, y){
		_shift = shift;

		if(delta < 0){
		//メッセージを進める
			click();
		}else if(delta > 0){
		//履歴表示
			callSystemWindow(SYSWIN_HISTORY);
		}
	}
	function onMouseMove(x, y, shift){
	}

	function onKeyDown(key, shift){
		//終了処理中は入力を無視する。
		if(_end) return;

		_shift = shift;

		if(_startSelect){
			switch(key){
			case VK_UP : 
//			case VK_LEFT : 
			case VK_DOWN : 
//			case VK_RIGHT : 
			case VK_RETURN : 
				global.ChainItemBase.onKeyDown(key, shift);
				return;
			}
		}

		if(key == VK_RETURN ||	//クリック
		   key == VK_DOWN ||
		   key == VK_NEXT ||
		   key == VK_SPACE
		){
			click();

		//=======================================
		//ショーカットキー
		}else if( key == VK_ESCAPE){	//メッセージフレーム消去
			if(isAuto() || isSkip(true)){
				skip(false);	//スキップ解除
				auto(false);	//オート解除
			}else if(_advHide == false){
			//メッセージフレーム消去
				if(_msg.isActivation()){
				//フェード中ならなにもしない
				}else if(_msg.isShow() && _hitretState){
					hide(300);
				}else{
					show(300);
				}
			}
			rClick();
		}else if(key == VK_CONTROL){	//メッセージ送り
			click();
		//----------------------------------------
		@if(__DEBUGMODE__)
			}else if(( key == VK_F10 || key == VK_F11 ) && _scenario != ""){
			//現在のシナリオ・行をエディターで開く
				var exe = CONFIG.debugEditerPath;
				if(exe == ""){
					if(Storages.isExistentStorage("C:\\Program Files (x86)\\Hidemaru\\Hidemaru.exe")){
						exe = "C:\\Program Files (x86)\\Hidemaru\\Hidemaru.exe";
					}else if(Storages.isExistentStorage("C:\\Program Files\\Hidemaru\\Hidemaru.exe")){
						exe = "C:\\Program Files\\Hidemaru\\Hidemaru.exe";
					}
				}
				if(exe == ""){
					var param = %[];
					with(param){
						.title = "テキストエディターを選択してください";
						.filter = ["エディター(*.exe)|*.exe"];
						.initialDir = "";
					}

					Storages.selectFile(param);
					if(param.name != "")
						exe = Storages.getLocalName(param.name);
					else
						exe = "C:\\Windows\\notepad.exe";
				}
				CONFIG.debugEditerPath = exe;
				exe = exe.toUpperCase();

				var file = Storages.getPlacedPath(_scenario + ".ks");
				var path = Storages.getLocalName(file);
				var param = path;
				if(exe.indexOf("HIDEMARU") != -1)	//秀丸なら行指定も
					param = "/j%d ".sprintf(_scCtrl.curLine) + path;

				if(Storages.isExistentStorage(exe))
					System.shellExecute(exe, param);
				else
					System.shellExecute(path);
			}else if(key == VK_P){
				//アクションタイマの一時停止・再開
				if(!_actionTimeKeeper.isPause())
					pauseAction();
				else
					restartAction();
			}else if(key == VK_D){
				cleaningADVObjectList();
			}else if(key == VK_A){
		@endif

		//----------------------------------------
		//ファンクション
		}else if( key == VK_F1){	//Q.save
			quickSave();
		}else if( key == VK_F2){	//Q.load
			if(saveMan.qsaveStack()){
				var save = saveMan.atQSave();
				quickLoad(save.file);
			}
		}else if( key == VK_F3 && !(shift&ssAlt)){	//セーブ
			callSystemWindow(SYSWIN_SAVE);
		}else if( key == VK_F4){	//ロード
			callSystemWindow(SYSWIN_LOAD);
		}else if( key == VK_F5){	//コンフィグ
			callSystemWindow(SYSWIN_CONFIG);
		}else if( key == VK_F6){	//オート
			auto(!_msg.auto);
		}else if( key == VK_F7){	//スキップ
			skip(!_msg.skip);
		}else if( key == VK_F8 ||	//履歴
		          key == VK_PRIOR ||
		          key == VK_UP){
			callSystemWindow(SYSWIN_HISTORY);
		}else if( key == VK_F9){	//音声再生
			if(_msg._voice != "" && _hitretState){
				playVoice(%[file:_msg._voice, pan:_msg._pan, vol:_msg._volume, config:false]);
			}
		//---------------------------------------
		@if(__HARUKA__ == 0)
			}else if( key == VK_LEFT){	//
				if(!IsLoadProccesing()) jump(JUMPSTATE_SELECT_PREV);
			}else if( key == VK_RIGHT){	//
				if(!IsLoadProccesing()) jump(JUMPSTATE_SELECT_NEXT);
		@endif
		}

		if( isSkip(true) && !_startSelect &&
			(key == VK_RETURN || key == VK_SPACE || key == VK_ESCAPE)){
			skip(false);	//スキップ解除
		}
	}

	function onKeyUp(key, shift){
		_shift = shift;
	}

	//タイムアウト通知
	function onTimeOut(){
		_scCtrl.trigger("timeout");
	}

	function action(ev){
		//トランジション中にクリックされた
		if(ev.target == _sprTrans){
			switch(ev.type){
			case "onMouseDown":
				onMouseDown(ev.x, ev.y, ev.button, ev.shift);
				break;
			case "onMouseWheel":
				onMouseWheel(ev.shift, ev.delta, ev.x, ev.y);
				break;
			case "onKeyDown":
				onKeyDown(ev.key, ev.shift);
				break;
			}

		//サウンドイベント
		}else if(ev.type == "onStatusChanged" && ev.status == "stop"){
			var snd = ev.target;
			if(BGM.indexOfObject(snd) != -1){
				_scCtrl.trigger("bgm_end");
			}else if(SE.indexOfObject(snd) != -1){
				_scCtrl.trigger("se_end");
			}else if(ENVSE.indexOfObject(snd) != -1){
				_scCtrl.trigger("envse_end");				//
				_scCtrl.trigger("envse_end:"+snd.id);		//idを追加したトリガーも引く
			}else if(VOICE.indexOfObject(snd) != -1){
				//同時音声の場合は最後に終了した音声のみトリガーを引く
				if(!VOICE.isPlay() && _scCtrl.isTrigger("voice_end")){
					_scCtrl.trigger("voice_end");
					if(_face != "") _face = "";
				}

				if(!VOICE.isPlay()){
				//全ての音声が終了した
					if(_fPlayedVoice){
						if(checkAutoEvent(AUTOSTATE_VOICE_END)){click();}
						_fPlayedVoice = false;
					}
				}

				checkRestartBgv(snd.id.substring(0, 3));

				@if(__DEBUGMODE__)
					//_msg.stopVoice();
				@endif
			}else if(SYSTEMSOUND.indexOfObject(snd) != -1){
				_scCtrl.trigger("system_end");
			}
		}else if(ev.type == "onStatusChanged" && ev.status == "play"){
			var snd = ev.target;
			if(BGM.indexOfObject(snd) != -1){
				_scCtrl.trigger("bgm_play");
			}else if(SE.indexOfObject(snd) != -1){
				_scCtrl.trigger("se_play");
			}else if(ENVSE.indexOfObject(snd) != -1){
				_scCtrl.trigger("envse_play");
			}else if(VOICE.indexOfObject(snd) != -1){
				_scCtrl.trigger("voice_play");
			}else if(SYSTEMSOUND.indexOfObject(snd) != -1){
				_scCtrl.trigger("system_play");
			}
		//ムービーイベント
		}else if(ev.type == "Movie.onStatusChanged" && ev.status == "play"){
			_scCtrl.trigger("movie_start");
		}else if(ev.type == "Movie.onStatusChanged" && ev.status == "stop"){
			_scCtrl.trigger("movie_end");
			onStopMovie();

		//スタッフロール終了
		}else if(ev.type == "staffroll_end"){
			_scCtrl.trigger("staffroll_end");

		//ウィンドウアクティブ・非アクティブ
		}else if(ev.type == "onActivate"){
			_shift = 0x0;
			if(System.getKeyState(VK_SHIFT)) _shift |= ssShift;
			if(System.getKeyState(VK_MENU)) _shift |= ssAlt;
			if(System.getKeyState(VK_CONTROL)){
				_shift |= ssCtrl;
				click();
			}
		}else if(ev.type == "onHideConfirm"){
		//確認ウィンドウが閉じられた
			if(_scCtrl.isTrigger("voice_end") && !VOICE.isPlay()){
				click();
			}
		}else if(ev.type == "onDeactivate"){

		}else if(ev.type == "onCloseQuery"){
		//閉じるボタンが押された
			if(isAuto()) auto(false, true);
//			if(isSkip()) skip(false);
			if(isSkip()) _requestStopSkip = true;

			if(!game.enableClose) return;		//閉じるボタン抑制

//			if(!_hitretState && !IsPlayMovie() && !IsStaffRoll())
//				_scCtrl.wait(_hitretWaitUntil);
		}
	}

	function onButtonDownL(target){
		if(_startSelect){
			for(var i=0;i<_select.count;i++){
				_selectBtn[i].btn.hitThreshold = 256;
				if((target == _selectBtn[i].btn)){
					decideSelect(i);

					//選択肢が決定された。
					//これ以降は_hitretStateがtrueになるまでＱセーブが抑制される。
					_hitretState = false;

					//if(CONFIG.lockSkip == 0 && isSkip())
					//	skip(false);
				}else{
				}
			}

			endSelect();

			if(CONFIG.voiceStopOnClick){
			//音声再生中にクリックが発生した場合は停止する
				_fPlayVoice = false;
				if(VOICE.isPlay()) StopVoice();
			}
		}
	}
	function onButtonDownR(target){
		onMouseDown(0, 0, mbRight, 0);
	}
	function onButtonEnter(target){
		if(_startSelect){
		}
	}

	//タグハンドラ
	function getHandlers(){
		return %[

		//メッセージ処理系
		talk : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			var name = GetElm(elm.name, "心の声");
			var pan = GetElm(elm.pan, "");
			var voice = GetElm(elm.voice, "");
			var vol = GetElm(elm.vol, "");
			var freeFromat = (elm.freeformat !== void);

			talk(name, voice, pan, vol, freeFromat);

			//以降、改行コードの取得を有効にする。
			//改行コードを取得する範囲は@Talk〜@Hitret
			_scCtrl.ignoreCR = false;

			return taghandler_end;
		} incontextof this,

		ch : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			ch(elm.text);
			return taghandler_getcontinue;
		} incontextof this,
		r : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			ch("／");
			return taghandler_getcontinue;
		} incontextof this,

		font : function(elm){
			_fFont = true;
			_fontElm.face = GetElm(elm.face, ADV_FONT_MESS_FACE);
			_fontElm.size = GetElm(elm.size, ADV_FONT_MESS_SIZE);
			_fontElm.indent = int GetElm(elm.indent, ADV_FONT_MESS_INDENT);

			_fontElm.bold = GetElm(elm.bold, 1, 0);

			_fontElm.italic = GetElm(elm.italic, 1, 0);

			if(elm.color !== void)
				_fontElm.color = GetDefineColor(elm.color) & 0xffffff;
			else
				_fontElm.color = -1;

			if(elm.bkcolor)
				_fontElm.bkcolor = GetDefineColor(elm.bkcolor) & 0xffffff;
			else
				_fontElm.bkcolor = -1;

			return taghandler_getcontinue;
		} incontextof this,

		partmess : function(elm){
			_partMess.add(
			%[mess:elm.mess, face:elm.face, size:elm.size, color:elm.color, bkcolor:elm.bkcolor, bold:elm.bold, italic:elm.italic]
			);

			return taghandler_getcontinue;
		} incontextof this,

		ruby : function(elm){
			if(_fLoad) return taghandler_getcontinue;
			if(elm.mess === void || elm.read === void) return;

			_ruby.add(%[mess:elm.mess, read:elm.read]);

			return taghandler_getcontinue;
		} incontextof this,

		ignorekinsoku : function(elm){
			_fIgnoreKinsoku = true;
			return taghandler_getcontinue;
		} incontextof this,

		scene : function(elm){
			_scene = elm.text;
			return taghandler_getcontinue;
		} incontextof this,

		hitret : function(elm){
			//以降、改行コードの取得を無効にする。
			_scCtrl.ignoreCR = true;

			if(_fLoad && _hitretCnt > 0){
			//まだ復帰地点まで移動中。。。
				if(_fFont) resetFontElm();

				_hitretCnt--;
				return taghandler_getcontinue;
			}

			var id = GetElm(elm.id, 0);
			hitret(id, elm.newline!==void?true:false);

			_hitretWaitUntil = %[
			click : function(){
			} incontextof this
			];

			_hitretState = false;

			if(isSkip()){
			//Ctrl押下中はシナリオを止めずに進める。
				if(_face != "") _face = "";

				return taghandler_getcontinue;
			}else{
				_hitretState = true;		//hitret中

				//シナリオを停止して入力待ち。
				if(elm.timeout === void)
					_scCtrl.wait(_hitretWaitUntil);
				else{
					_hitretWaitUntil.timeout = function {};
					_scCtrl.waitTimeOut(_hitretWaitUntil, int(elm.timeout));
				}

				if(isAuto() && !_fPlayedVoice && !_msg.isPending()){
					startAutoTimer();
				}

				return taghandler_end;
			}
		} incontextof this,
		hitwait : function(elm){
		//音声終了待ちも加えた@hitret
			if(_fLoad && _hitretCnt > 0){
			//まだ復帰地点まで移動中。。。
				if(_fFont) resetFontElm();

				_hitretCnt--;
				return taghandler_getcontinue;
			}

			var id = GetElm(elm.id, 0);
			hitret(id, elm.newline!==void?true:false);

			_hitretWaitUntil = %[
			click : function(){
			} incontextof this,
			voice_end : function(){
			} incontextof this
			];

			_hitretState = false;

			if(isSkip()){
			//Ctrl押下中はシナリオを止めずに進める。
				if(_face != "") _face = "";

				return taghandler_getcontinue;
			}else{
				_hitretState = true;

				//シナリオを停止して入力待ち。
				_scCtrl.wait(_hitretWaitUntil);

				if(isAuto() && !_fPlayedVoice && !_msg.isPending()){
					startAutoTimer();
				}

				return taghandler_end;
			}
		} incontextof this,

		show : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			show(ReviceEffectSpeed(300));
			if(elm.wait === void){
				return taghandler_getcontinue;
			}else{
				_scCtrl.wait( %[
				show_end : function(){
				} incontextof this
				]);

				return taghandler_end;
			}
		} incontextof this,

		hide : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			hide(ReviceEffectSpeed(300), true);
			if(elm.wait === void){
				return taghandler_getcontinue;
			}else{
				_scCtrl.wait( %[
				hide_end : function(){
				} incontextof this
				]);

				return taghandler_end;
			}
		} incontextof this,

		movewindow : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			var x, y;
			x = int GetElm(elm.x, 0);
			y = int GetElm(elm.y, 0);
			moveWindow(x, y);

			return taghandler_getcontinue;
		} incontextof this,

		//画面表示系
		cg : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			elm.file = GetElm(elm.file, "nofile").toUpperCase();
			addOrderList(elm);
			_update |= UPDATE_CG;

			return taghandler_getcontinue;
		} incontextof this,

		char : function(elm){
			if(_fLoad) return taghandler_getcontinue;
			if(elm.file === void || elm.file == "") return taghandler_getcontinue;

			elm.file = GetElm(elm.file, "nofile").toUpperCase();
			addOrderList(elm);
			_update |= UPDATE_BUSTUP;

			return taghandler_getcontinue;
		} incontextof this,

		clearchar : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			_update |= UPDATE_BUSTUP;

			return taghandler_getcontinue;
		} incontextof this,

		autoposition : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			_fBustupAutoPositioning = true;

			return taghandler_getcontinue;
		} incontextof this,

		charrelate : function(elm){
			_fBustupRelateFlip = elm.flip!==void?true:false;
			_update |= UPDATE_BUSTUP;

			return taghandler_getcontinue;
		} incontextof this,
		charrelatecustom : function(elm){
			if(elm.reset !== void)
				_bustupRelateCustom = "";
			else
				_bustupRelateCustom = GetElm(elm.set, "");

			_update |= UPDATE_BUSTUP;

			return taghandler_getcontinue;
		} incontextof this,

		update : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			elm.time = GetElm(elm.time, 500);

			var nowait = GetElm(elm.nowait, true, false);

			var ret = taghandler_getcontinue;
			if(isAuto() && _update & UPDATE_CG && !nowait){
			//オートモード中の全画面更新は更新終了を待つ
				_scCtrl.wait(
				%[
				click : function(){
				} incontextof this,
				transition_end : function(){
				} incontextof this
				]
				);
				ret = taghandler_end;
			}

			update(elm);

			return ret;
		} incontextof this,

		waitupdate : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isTransition()){
				if(elm.hitcancel === void){
					_scCtrl.wait(
					%[
					click : function(){
					} incontextof this,
					transition_end : function(){
					} incontextof this
					]
					);
				}else{
				//クリックキャンセル無効
					_scCtrl.wait(
					%[
					transition_end : function(){
					} incontextof this
					]
					);
				}

				return taghandler_end;
			}else{
				return taghandler_getcontinue;
			}
		} incontextof this,

		//カメラ操作
		cameraauto : function(elm){		//自動追尾
			if(_fLoad) return taghandler_getcontinue;

			cameraMode(camera_auto);
			return taghandler_getcontinue;
		} incontextof this,
		camerafix : function(elm){		//固定
			if(_fLoad) return taghandler_getcontinue;

			cameraMode(camera_fix);
			return taghandler_getcontinue;
		} incontextof this,

		movecamera : function(elm){
		/*
			カメラ位置変更
			elm.pos.x : 0で左右中央。正で右、負で左。
			elm.pos.y : 0で上下中央。正で下、負で上。
			elm.pos.z : 0で標準位置。正でズームアップ。負でズームダウン。
			elm.time : 0で瞬時移動
		*/
			if(_fLoad) return taghandler_getcontinue;

//			addOrderList(elm);
			moveCamera(elm);
			return taghandler_getcontinue;
		} incontextof this,
		waitcamera : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(!_fAction)
				return taghandler_getcontinue;

			if(!_fCamera_move)
				return taghandler_getcontinue;

			if(elm.hitcancel === void){
				_scCtrl.wait(
				%[
				click : function(){
				} incontextof this,
				movecamera_end : function(){
				} incontextof this
				]
				);
			}else{
			//クリックキャンセル無効
				_scCtrl.wait(
				%[
				movecamera_end : function(){
				} incontextof this
				]
				);
			}
			return taghandler_end;
		} incontextof this,

		//選択肢
		addselect : function(elm){
			addSelect(elm);
			return taghandler_getcontinue;
		} incontextof this,
		startselect : function(elm){
			if(_fLoad && _hitretCnt > 0){
				_hitretCnt--;

				_ret_select = _logSelect[_selectCnt];
				_ret_select_str = _select[_selectCnt-1];

				if(_select[_ret_select-1].label !== void){
					try{
						_scCtrl.goToLabel("*" + _select[_ret_select-1].label);
					}catch{
						dm("指定されたラベルが見つかりませんでした : *" + _select[_ret_select-1].label);
					}
				}

				_selectCnt++;

				_select.clear();
				return taghandler_getcontinue;
			}

			var select = startSelect(elm);
			if(!select) return taghandler_getcontinue;

			_hitretState = true;

			_scCtrl.wait(
			%[
			select : function(){
			} incontextof this
			]
			);

			return taghandler_end;
		} incontextof this,
		setselect : function(elm){
			_ret_select = int GetElm(elm.id, 0);
			return taghandler_getcontinue;
		} incontextof this,
		selectterminate : function(elm){
		//以後、選択肢は無いという目印。
		//選択肢ジャンプで参照する。
			SetParam(SELECTTERMINATE_FLAG, true);
			return taghandler_getcontinue;
		} incontextof this,

		//アクション
		action : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			asyncAction(elm);
/*
			var id = elm.id.split("/");
			for(var i=0;i<id.count;i++){
				elm.id = id[i];
				addOrderList(elm);
			}
			_update |= UPDATE_SOME;
*/
			return taghandler_getcontinue;
		} incontextof this,
		stopaction : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			return taghandler_getcontinue;
		} incontextof this,
		waitaction : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			//id指定が無い場合は無効
			if(elm.id === void) return taghandler_getcontinue;

			//更新があるならここでやってしまう
//			if(_update) update();

			//本体
			var index  = getADVObjectIndex(elm.id, true);
			if(index == -1){
			//本体がない。消えようとしているオブジェクトかも
				index  = getADVObjectIndex(elm.id+"-trans", true);
			}

			var target;
			if(index != -1){
			//ADVオブジェクト
				target = _objList[index];
			}else if(elm.id == "メッセージ"){
				target = _msg;
			}else if(elm.id == "カメラ"){
				target = _camera_pos;
			}else if(elm.id == "フェイス"){
				target = _msg._sprFace;
			}else{
				return taghandler_getcontinue;
			}

			//ターゲットオブジェクトがアクション中か
			if(!_actionList.isAction(target))
				return taghandler_getcontinue;

			//ループアクションだと終了しないので無効
			if(_actionList.sequence(target).isLoop())
				return taghandler_getcontinue;

			_actionWaitTarget = target;

			if(elm.hitcancel === void){
				_scCtrl.wait(
				%[
				click : function(){
				} incontextof this,
				action_end : function(){
				} incontextof this
				]
				);
			}else{
			//クリックキャンセル無効
				_scCtrl.wait(
				%[
				action_end : function(){
				} incontextof this
				]
				);
			}
			return taghandler_end;
		} incontextof this,

		//エモーション
		emotion : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			_update |= UPDATE_SOME;
			return taghandler_getcontinue;
		} incontextof this,
		stopemotion : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			return taghandler_getcontinue;
		} incontextof this,

		//キャラアクション用アクション・ラッパー
		//座標移動
		move : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(elm.left !== void) elm.mx = -int(elm.left);
			else if(elm.right !== void) elm.mx = int(elm.right);
			if(elm.top !== void) elm.my = -int(elm.top);
			else if(elm.bottom !== void) elm.my = int(elm.bottom);

			elm.tagname = "action";		//actionとして登録
			elm.action = "ActionAdvMove";
			addOrderList(elm);
			_update |= UPDATE_BUSTUP;
			return taghandler_getcontinue;
		} incontextof this,
		//登場
		enter : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			var flush = GetElm(elm.flush, false);

			if(elm.mx !== void) elm.mx = int(elm.mx);
			else if(elm.left !== void) elm.mx = -int(elm.left);
			else if(elm.right !== void) elm.mx = int(elm.right);
			else elm.mx = -100;
			elm.x = int(elm.x) + int(elm.mx);
			if(elm.my !== void) elm.my = int(elm.my);
			else if(elm.top !== void) elm.my = -int(elm.top);
			else if(elm.bottom !== void) elm.my = int(elm.bottom);
			elm.y = int(elm.y) + int(elm.my);

			//ファイル名からIDを調べる
			var info = new ADVObjectInfo();
			SetupBustup(info, elm.file);
			//idが指定されているときはそれを使用する
			if(elm.id !== void) info.id = elm.id;

			if(!flush){
				//charとして登録
				elm.tagname = "char";
				//elm.tempPosition = true;	//座標指定があっても自動位置調整設定を保持させる
				addOrderList(elm);

				//actionとして登録
				addOrderList(%[tagname:"action", id:info.id, action:"ActionAdvMove", mx:-elm.mx, my:-elm.my, cycle:elm.cycle, accel:elm.accel]);
			}else{
				//charとして登録
				elm.tagname = "char";
				elm.x -= elm.mx;
				elm.y -= elm.my;
				//elm.tempPosition = true;	//座標指定があっても自動位置調整設定を保持させる
				addOrderList(elm);
			}

			_update |= UPDATE_BUSTUP;
			return taghandler_getcontinue;
		} incontextof this,
		//去る
		leave : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(elm.mx !== void) elm.mx = int(elm.mx);
			else if(elm.left !== void) elm.mx = -int(elm.left);
			else if(elm.right !== void) elm.mx = int(elm.right);
			else elm.mx = 100;
			if(elm.my !== void) elm.my = int(elm.my);
			else if(elm.top !== void) elm.my = -int(elm.top);
			else if(elm.bottom !== void) elm.my = int(elm.bottom);
			elm.y = int(elm.y) + int(elm.my);

			elm.tagname = "action";		//actionとして登録
			elm.action = "ActionAdvMoveFadeOut";
			addOrderList(elm);

			addOrderList(%[tagname:"clearchar", id:elm.id]);

			var obj = getADVObjectObject(elm.id);
			if(obj == -1){
				_fBustupAutoPositioning = false;			//自動位置調整を無効に。
			}else{
				//フリーオブジェクトでないなら
				if(!(obj.kind & ADVOBJ_BUSTUP_FREE))
					_fBustupAutoPositioning = false;			//自動位置調整を無効に。
			}

			_update |= UPDATE_BUSTUP;
			return taghandler_getcontinue;
		} incontextof this,

		//カットイン
		cutin : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			if(elm.file !== void || elm.hide !== void)
				_update |= UPDATE_CUTIN;

			return taghandler_getcontinue;
		} incontextof this,

		//フラグ系
		onflag : function(elm){
			onFlag(elm.id);
			return taghandler_getcontinue;
		} incontextof this,
		offflag : function(elm){
			offFlag(elm.id);
			return taghandler_getcontinue;
		} incontextof this,
		setparam : function(elm){
			var pos = PointStrToNum(elm.arg);
			setParam(pos.x, pos.y);
			return taghandler_getcontinue;
		} incontextof this,
		addparam : function(elm){
			var pos = PointStrToNum(elm.arg);
			addParam(pos.x, pos.y);
			return taghandler_getcontinue;
		} incontextof this,
		clearparam : function(elm){
			var pos = PointStrToNum(elm.arg);
			clearParam(pos.x, pos.y);
			return taghandler_getcontinue;
		} incontextof this,
		//グローバルフラグ
		onglobalflag : function(elm){
			onGlobalFlag(elm.id);
			return taghandler_getcontinue;
		} incontextof this,
		offglobalflag : function(elm){
			offGlobalFlag(elm.id);
			return taghandler_getcontinue;
		} incontextof this,
		//CGフラグ
		oncgflag : function(elm){
			onCgFlag(elm.id);
			return taghandler_getcontinue;
		} incontextof this,
		offcgflag : function(elm){
			offCgFlag(elm.id);
			return taghandler_getcontinue;
		} incontextof this,

		//バッグログ
		clearlog : function(elm){
			clearLog();
			return taghandler_getcontinue;
		} incontextof this,

		//音楽・効果音系
		playbgm : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			playBgm(elm);
			return taghandler_getcontinue;
		} incontextof this,

		stopbgm : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			stopBgm(elm);
			return taghandler_getcontinue;
		} incontextof this,

		changebgmspeed : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			changeBgmSpeed(elm);
			return taghandler_getcontinue;
		} incontextof this,

		fadebgm : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			fadeBgm(elm);
			return taghandler_getcontinue;
		} incontextof this,

		playse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			playSe(elm);
			return taghandler_getcontinue;
		} incontextof this,

		stopse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			stopSe(elm);
			return taghandler_getcontinue;
		} incontextof this,

		playenvse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			playEnvSe(elm);
			return taghandler_getcontinue;
		} incontextof this,

		stopenvse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			stopEnvSe(elm);
			return taghandler_getcontinue;
		} incontextof this,

		fadeenvse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			fadeEnvSe(elm);
			return taghandler_getcontinue;
		} incontextof this,

		playvoice : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			playVoice(elm);
			return taghandler_getcontinue;
		} incontextof this,
		stopvoice : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			stopVoice(elm);
			return taghandler_getcontinue;
		} incontextof this,

		playbgv : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			playBgv(elm);
			return taghandler_getcontinue;
		} incontextof this,

		stopbgv : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			stopBgv(elm);
			return taghandler_getcontinue;
		} incontextof this,

		//演出系
		blackout : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			elm.tagname = "cg";
			elm.file = "BLACK";
			addOrderList(elm);
			_update |= UPDATE_CG;

			elm.color = "BLACK";
			elm.enter = int GetElm(elm.time, 1000);
			elm.leave = 0;

			var func = getHandlers()["flash"];
			return func(elm);

		} incontextof this,
		whiteout : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			elm.tagname = "cg";
			elm.file = "WHITE";
			addOrderList(elm);
			_update |= UPDATE_CG;

			elm.color = "WHITE";
			elm.enter = int GetElm(elm.time, 1000);
			elm.leave = 0;

			var func = getHandlers()["flash"];
			return func(elm);
		} incontextof this,
		colorout : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			colorOut(elm);

			if(isSkip())
				return taghandler_end;

			if(!_sprTrans.isTransition()){
				return taghandler_end;
			}else if(elm.hitcancel === void){
				_scCtrl.wait(
				%[
				click : function(){
				} incontextof this,
				transition_end : function(){
				} incontextof this
				]
				);
			}else{
				_scCtrl.wait(
				%[
				transition_end : function(){
				} incontextof this
				]
				);
			}

			return taghandler_end;
		} incontextof this,

		flash : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip()){
				flashEnter(elm);
				flashLeave();
				return taghandler_end;
			}

			if(_sprFlash !== void){
				flashEnd();
			}

			flashEnter(elm);

			if(elm.hitcancel === void){
				_scCtrl.wait(
				%[
				click : function(){
				} incontextof this,
				flash_end : function(){
				} incontextof this
				]
				);
			}else{
				_scCtrl.wait(
				%[
				flash_end : function(){
				} incontextof this
				]
				);
			}

			return taghandler_end;
		} incontextof this,

		tone : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			_update |= UPDATE_CG;

			return taghandler_getcontinue;
		} incontextof this,

		focus : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			addOrderList(elm);
			_update |= UPDATE_CG | UPDATE_FOCUS;
			//focus(elm);
			return taghandler_getcontinue;
		} incontextof this,

		//シナリオ制御系
		//指定時間待ち
		wait : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			if(elm.hitcancel === void){
				_scCtrl.waitTimeOut( %[
				click : function(){
				} incontextof this,
				wait : function(){
				} incontextof this,
				timeout : function(){
				} incontextof this
				],
				elm.time);
			}else{
				_scCtrl.waitTimeOut( %[
				wait : function(){
				} incontextof this,
				timeout : function(){
				} incontextof this
				],
				elm.time);
			}
			return taghandler_end;
		} incontextof this,
		//音楽の終了待ち
		waitbgm : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			if(BGM.isPlay()){
				_scCtrl.wait( %[
				click : function(){
				} incontextof this,
				bgm_end : function(){
				} incontextof this
				]);
				return taghandler_end;
			}else{
				return taghandler_getcontinue;
			}
		} incontextof this,
		//効果音の終了待ち
		waitse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			if(SE.isPlay()){
				_scCtrl.wait( %[
				click : function(){
				} incontextof this,
				se_end : function(){
				} incontextof this
				]);
				return taghandler_end;
			}else{
				return taghandler_getcontinue;
			}
		} incontextof this,
		//環境音の終了待ち
		waitenvse : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			var f = false;
			if(elm.id !== void){
			//id指定があった
				var obj;
				if((obj = ENVSE.objectOfId(elm.id, false)) != -1){
					if(obj._waitEnding)
					//バッファが存在して止まろうとしている
						f = true;
				}
			}else{
			//指定なし
				f = ENVSE.isPlay();
			}

			if(f){
				if(elm.id === void){
					_scCtrl.wait( %[
					click : function(){
					} incontextof this,
					envse_end : function(){
					} incontextof this
					]);
				}else{
					var wait = %[];
					wait.click = function {};
					wait["envse_end:"+elm.id.toUpperCase()] = function {};
					_scCtrl.wait(wait);
				}
				return taghandler_end;
			}else{
				return taghandler_getcontinue;
			}
		} incontextof this,
		//音声の終了待ち
		waitvoice : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			var fPlay = VOICE.isPlay();

			if(fPlay){
				if(elm.hitcancel === void){
					_scCtrl.wait( %[
					click : function(){
					} incontextof this,
					voice_end : function(){
					} incontextof this
					]);
				}else{
					_scCtrl.wait( %[
					voice_end : function(){
					} incontextof this
					]);
				}
				return taghandler_end;
			}else{
				return taghandler_getcontinue;
			}
		} incontextof this,
		pausebgm : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			pauseBgm();
		} incontextof this,
		restartbgm : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			restartBgm();
		} incontextof this,
		//トランジッションの終了待ち
		waittransition : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			_scCtrl.wait( %[
			click : function(){
			} incontextof this,
			transition_end : function(){
			} incontextof this
			]);
			return taghandler_end;
		} incontextof this,
		//スクロールの終了待ち
		waitscroll : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			if(isSkip())
				return taghandler_end;

			_scCtrl.wait( %[
			click : function(){
			} incontextof this,
			scroll_end : function(){
			} incontextof this
			]);
			return taghandler_end;
		} incontextof this,

		eval : function(elm)
		{
			// 式の評価
			Scripts.eval(elm.exp);
			return taghandler_getcontinue;
		} incontextof this,

		//ファイルチェンジ
		change : function(elm){
			var param = elm.target.split(",/");
			change(param[0], param[1], true);
			return taghandler_getcontinue;
		} incontextof this,

		//ロゴに戻る
		tologo : function(elm){
			_enableAutoSave = false;
			returnTo(SCENE_LOGO, elm);

			return taghandler_end;
		} incontextof this,

		//タイトルに戻る
		totitle : function(elm){
			_enableAutoSave = false;
			returnTo(SCENE_TITLE, elm);

			return taghandler_end;
		} incontextof this,

		//回想に戻る
		torecollect : function(elm){
			_enableAutoSave = false;
			returnTo(SCENE_MEMORIES, elm);

			return taghandler_end;
		} incontextof this,

		//回想中なら回想に戻る
		recollect : function(elm){
			var id = int GetElm(elm.id, -1);
			if(_fRecollect){
				_enableAutoSave = false;
				returnTo(SCENE_MEMORIES, elm);
				return taghandler_end;
			}

			//フラグをオン
			if(id != -1) SetGlobalFlag(id, true);

			return taghandler_getcontinue;
		} incontextof this,

		//シナリオ終端
		terminate : function(elm){
			_enableAutoSave = false;

			if(!_fPreviewMode) returnTo(SCENE_LOGO, elm);

			return taghandler_end;
		} incontextof this,

		//ムービーの再生
		playmovie : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			playMovie(elm);

			if(elm.hitcancel === void){
				_scCtrl.wait( %[
				rclick : function(){
				} incontextof this,
				movie_end : function(){
				} incontextof this
				]);
			}else{
				_scCtrl.wait( %[
				movie_end : function(){
				} incontextof this
				]);
			}

			return taghandler_end;
		} incontextof this,

		staffroll : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			staffroll(elm);

			_scCtrl.wait( %[
			staffroll_end : function(){
			} incontextof this
			]);
		} incontextof this,

		//環境エフェクト系
		snow : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			envEffect(ENVEFFECT_SNOW, elm);

			return taghandler_getcontinue;
		} incontextof this,
		rain : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			envEffect(ENVEFFECT_RAIN, elm);

			return taghandler_getcontinue;
		} incontextof this,
		bgscroll : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			envEffect(ENVEFFECT_BG_SCROLL, elm);

			return taghandler_getcontinue;
		} incontextof this,

		//閉じるボタン有効／無効
		canclose : function(elm){
			if(elm.yes !== void) game.enableClose = true;
			if(elm.no !== void) game.enableClose = false;
			return taghandler_getcontinue;
		} incontextof this,

		//デバック用メッセージ
		dm : function(elm){
			dm(elm.text);
			return taghandler_getcontinue;
		} incontextof this,

		//ゲーム固有コマンド
		eyecatch : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			eyeCatch(elm);
			if(isSkip()) return taghandler_getcontinue;

			_scCtrl.wait( %[
			eyecatch_end : function(){
			} incontextof this
			]);

			return taghandler_end;
		} incontextof this,
		cinema : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			cinema(elm);

			return taghandler_getcontinue;
		} incontextof this,
		messageframe : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			messageFrame(elm);

			return taghandler_getcontinue;
		} incontextof this,
		face : function(elm){
			if(_fLoad) return taghandler_getcontinue;

			var file = "";
			if(elm.hide !== void){
				_msg.face("hide");
			}else if(elm.show !== void){
				_msg.face("show");
			}else if(elm.hideonce !== void){
				file = "hideonce";
			}else if(elm.file !== void){
				file = elm.file;
			}
			_face = file;

			return taghandler_getcontinue;
		} incontextof this,
		];
	}

	//コマンドファンクション
	function talk(name="心の声", voice="", pan="", vol="", freeFormat=false){
		cleaningADVObjectList();

		_name = name;
		_mess = "";
		_voice = voice;
		_pan = pan;
		_volume = vol;
		_fFreeFormat = freeFormat;
	}

	function ch(code){
		_mess += code;
	}

	function hitret(id=0, newline=false){
		_lastHitretID = id;

		var fLoadEnd = false;
		if(_fLoad){
			loadEnd();
			fLoadEnd = true;
		}else{
			if(_update) update();
			if(_orderList.count) processOrder(_orderList);

			_hitretNum++;
		}

		//オートセーブ仮保存
		if(!_jumpState){
			_autoSave.init();
			_autoSave.set(this, true, false, false);
		}

		_quickSave = false;

		//表示名とキャラ名を分離
		//@talk 表示名/キャラ名
		//分離できないものは表示名=キャラ名
		var name = _name.split("/");
		var trueName;
		var dispName;
		switch(name.count){
		case 1 : 
			dispName = name[0];
			break;
		default : 
			dispName = name[1];
			break;
		}
		trueName = name[0];

		//語尾の強制改行を削る
		if(_mess.charAt(_mess.length-1) == "／")
			_mess = _mess.substring(0, _mess.length-1);

		//文字装飾
		for(var i=0;i<_partMess.count;i++){
			with(_partMess[i]){
				var mess = .mess;
				var reg = new RegExp(mess, "g");
				if(.face !== void){
					var replace = "$f:" + .face + ";" + mess + "$fd;";
					_mess = _mess.replace(reg, replace);
				}
				if(.color !== void){
					var color = .color;
					var bkcolor = .bkcolor;
					var replace = "$c:" + color + "," + bkcolor + ";" + mess + "$c;";
					_mess = _mess.replace(reg, replace);
				}
				if(.size !== void){
					var replace = "$s:" + .size + ";" + mess + "$sd;";
					_mess = _mess.replace(reg, replace);
				}
				if(.bold !== void){
					var replace = "$b;" + mess + "$bd;";
					_mess = _mess.replace(reg, replace);
				}
				if(.italic !== void){
					var replace = "$i;" + mess + "$id;";
					_mess = _mess.replace(reg, replace);
				}
				invalidate reg;
			}
		}
		_partMess.clear();
		//ルビ
		for(var i=0;i<_ruby.count;i++){
			var mess = _ruby[i].mess;
			var read = _ruby[i].read;
			var replace = "$r:" + mess + "," + read + ";";
			var reg = new RegExp(mess, "g");
			_mess = _mess.replace(reg, replace);
			invalidate reg;
		}
		_ruby.clear();

		//既読フラグチェック
		var fRead = ChkReadFlag(id);
		if(!fRead){
			SetReadFlag(id, true);
			@if(__DEBUGMODE__ == 0)
				if(isSkip(true) && CONFIG.readSkip == 1) skip(false, false, true);	//スキップを解除する
			@endif
			@if(__DEBUGMODE__ != 0)
				if(isSkip(true) && CONFIG.readSkip == 1 && _strSearch.length == 0) skip(false, false, true);	//スキップを解除する
			@endif
		}

		//音声再生
		if(_jumpState == JUMPSTATE_NONE)
			playVoice(%[file:_voice, pan:_pan, vol:_volume]);

		//ログ保存
		if(fLoadEnd == false){
			var sel = [];
			sel.assignStruct(_logSelect);
			addLog(_name, _mess, _voice, %[font:%[], pan:_pan, volume:_volume, newline:newline, scenario:_scenario, hitret:_hitretNum, select:sel, id:id]);
			var refFont = _logParam[_logParam.count-1].font;
			if(_fFont){
				(Dictionary.assign incontextof refFont)(_fontElm);
			}else{
				(Dictionary.assign incontextof refFont)(_msg.fontMess);
			}
		}

		if(!fLoadEnd) _autoState = 0;	//オート状態リセット

		//トランジションが発生してないので完了扱い
		if(!_sprTrans.isTransition())
			checkAutoEvent(AUTOSTATE_TRANSITION_END);

		//音声は再生されなかったので完了扱い
		if(!_fPlayedVoice)
			checkAutoEvent(AUTOSTATE_VOICE_END);

		_advHide = false;	//メッセージ表示の解除

		//サーチスキップ
		if(_strSearch.length != 0 && isSkip(true)){
			if(_mess.indexOf(_strSearch) != -1){
			//検索文字列が見つかった
				_strSearch = "";
				skip(false, false, true);
			}
		}
		//スキップ停止要求
		if(_requestStopSkip){
			if(isSkip()) skip(false);
			_requestStopSkip = false;
		}

		//メッセージ出力
		if(!fLoadEnd && !_jumpState)
			outputMessage(dispName, _mess, _voice, _pan, _volume, false, fRead, trueName, newline);

		_fFreeFormat = false;
	}

	function clearMessage(){
		_msg.clear();
	}

	function outputMessage(name, mess, voice, pan, volume, flush=false, fRead, trueName="", newline=false){
		if(_fFont){
			_msg.output(name, mess, voice, pan, volume, isSkip()|flush, _fontElm, _fIgnoreKinsoku, fRead, trueName, _face, newline);
		}else{
			_msg.output(name, mess, voice, pan, volume, isSkip()|flush, null, _fIgnoreKinsoku, fRead, trueName, _face, newline);
		}

		if(!_msg.isShow()){
			_msg.showMessage(0);
			show(ReviceEffectSpeed(300));
		}

		if(_fFont) resetFontElm();
		if(_fIgnoreKinsoku) _fIgnoreKinsoku = false;
	}

	function resetFontElm(){
		_fFont = false;
		_fontElm.face = ADV_FONT_MESS_FACE;
		_fontElm.size = ADV_FONT_MESS_SIZE;
		_fontElm.indent = ADV_FONT_MESS_INDENT;
		_fontElm.face = ADV_FONT_MESS_FACE;
		_fontElm.bold = 0;
		_fontElm.italic = 0;
		_fontElm.color = -1;
		_fontElm.bkcolor = -1;
	}

	function transitionComplete(dest, src){
		_sprTrans.stopTransition();
		_sprTrans.visible = false;

		_autoState |= AUTOSTATE_TRANSITION_END;

		if(isTransition() == false){
			if(_sprTrans == dest){
				_scCtrl.trigger("transition_end");

				if(checkAutoEvent(AUTOSTATE_TRANSITION_END) && _hitretState){
					if(_fPlayedVoice){
						if(_msg.isPending())	startAutoTimer();
						else					click();
					}else{
						startAutoTimer();
					}
				}

				//トランジションが終了したらADVScreenを閉じるようにする
				if(_end) close();
			}
		}
	}

	function cg(elm=%[]){
	//elm.file
	//elm.pos
		_update |= UPDATE_CG;
		_fBustupAutoPositioning = true;

		//アクション中なら止める
		if(_actionList.count) _actionList.stopAction();

		//環境エフェクト系を止める
		if(isEnvEffect()) stopEnvEffect();

		//バストアップ全消去
		//elm.clearタグが登録されていない、もしくは1なら消去
		if(elm.clear === void){
		//タグなし
			clearChar();
			cutin(%[hide:1]);
		}else if(elm.clear == 1){
		//1が設定されている
			clearChar();
			cutin(%[hide:1]);
		}

		_envTone = TONE_DIC["normal"];	//環境トーン初期化

		var tempFile = elm.file;
		var info = new ADVObjectInfo();
		SetupCg(this, info, elm.file, elm.envtone);
		elm.file = info.file;

		var head = elm.file.substring(0, 4);
		_fHScene = (CG_HSCENE_LIST[head] !== void);

		var id = getADVObjectIndex("背景");
		with(_objList[id]){
			.info.copy(info);

			if(elm.color === void){
				var success = .setup(elm);

				@if(__DEBUGMODE__)
				//ファイル情報を書き込む
					if(!success){
						.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
						._spr.setImageSize(WINDOW_WIDTH, WINDOW_HEIGHT);
						._spr.fillRect(0, 0, .width, .height, RGBA(64, 64, 64));
						info.center.set(WINDOW_WIDTH/2, WINDOW_HEIGHT/2);
					}
					if(debug.tglSupExp.state){
						if(tempFile[0] == "E") tempFile = tempFile.substring(0, 9);
						var text = CG_INFO[tempFile];
						if(text === void) text = elm.file;

						var texts = text.split("/");
						var y = (._spr.height-._spr.font.height)/2 - 220;
						for(var i=0;i<texts.count;i++){
							._spr.font.height = 24 + random(12);
							var w = ._spr.font.getTextWidth(texts[i]);
							._spr.drawText((._spr.width-w)/2, y, texts[i], RGB(127+random(128), 127+random(128), 127+random(128)), 255, true, 1024, 0x0, 2);
							y += ._spr.font.height + 4;
						}
					}
				@endif
			}else{
				._spr.setImageSize(WINDOW_WIDTH, WINDOW_HEIGHT);
				._spr.fillRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, int(elm.color) | 0xff000000);
			}

			.setSizeToImageSize();

			//typeとfaceをOpaqueにする。
			._spr.type = ltOpaque;
			._spr.face = dfOpaque;

			if(elm.center == -1){
				.setCenter(int(.imageWidth\2), int(.imageHeight\2));
			}else if(elm.center !== void){
				var pos = PointStrToNum(elm.center);
				.setCenter(pos.x, pos.y);
			}else if(info.center.x !== ADVOBJ_NULL){
				.setCenter(info.center.x, info.center.y);
			}else{
				.setCenter(400, 300);
			}

			if(elm.blur !== void){
				.doBoxBlur(int(elm.blur), int(elm.blur));
			}

			@if(__DEBUGMODE__)
				debug.setCameraRange(._spr._image, .info.center.x, .info.center.y);
				debug.setCameraPos(_camera_pos.x, _camera_pos.y);
			@endif
			//カメラ位置の調整
			if(elm.pos === void){
				moveCamera(%[pos:"%d,%d,%d".sprintf(GetElm(elm.x, 0), GetElm(elm.y, 0), GetElm(elm.z, 0)), time:0]);		//x, y, z指定
			}else{
				moveCamera(%[pos:elm.pos, time:0]);		//任意
			}

			_eventSceneSizeL = false;
			if(.imageType == ADVObject.IMAGETYPE_FILE && .file.charAt(0) == "E"){
			//イメージタイプがファイルかつ、ファイル名の先頭がのときイベントシーン
				if(.file.charAt(EVENT_SIZE_CHECK_INDEX) == "L"){
				//ファイル名の最後がLの時、LサイズのイベントＣＧ
					_eventSceneSizeL = true;
				}
				_sceneType = SCENETYPE_EVENT;
			}else{
				_sceneType = SCENETYPE_NORMAL;
			}
		}
		invalidate info;
	}

	function char(elm=%[]){
	//elm.file
	//elm.pos
	//elm.trans
		var check = UPDATE_CG|UPDATE_BUSTUP;
		var info = new ADVObjectInfo();
		SetupBustup(info, elm.file);	//バストアップの情報を取得
		if(info.id == -1){
//			dm("バストアップファイルではありません : " + elm.file);
//			return;
		}

		//idが指定されているときはそれを使用する
		if(elm.id !== void) info.id = elm.id;

		var newObject = false;
		var transIndex;
		var index = getADVObjectIndex(info.id);
		var preWorld = new Point();
		var preFocus = -1;
		var preTone = "";
		var preTrans = -1;

		if(index == -1){
		//新規ID
			index = addADVObject(info.id);
			newObject = true;
			_objList[index].fresh = true;
		}else{
		//既に存在するIDなので、入れ替え処理

			//なにかアクション中なら停止する
			if(_actionList.isAction(_objList[index])) _actionList.stopAction(_objList[index]);

			//なにかエモーション中なら停止する
			if(_objList[index].isEmotion()) _objList[index].resetEmotion();

			preWorld.set(_objList[index].world);	//現在の座標を保存
			preFocus = _objList[index]._focus;
			if(elm.tone === void)
				preTone = _objList[index]._tone;
			preTrans = _objList[index].opacity;
			if(elm.zoom === void && _objList[index].zoomBase)
				elm.zoom = _objList[index].zoomBase;

			transIndex = getADVObjectIndex(info.id+"-trans");
			if(transIndex != -1){
			//ID+"-trans" が存在するということは、トランジション処理中ということなので削除して新規IDとして扱う。
				removeADVObject(info.id+"-trans");
				newObject = true;
			}else{
				//現在のIDを変更
				_objList[index].id = _objList[index].id + "-trans";
				_objList[index].destroy = ADVOBJ_DESTROY_WAIT;	//必要なくなったら自滅させる
				transIndex = index;
			}

			//新規ADVObject作成
			index = addADVObject(info.id);
			_objList[index].absolute = _objList[transIndex].absolute;
			info.kind = _objList[index].kind = _objList[transIndex].kind;

			//旧システム仕様　オーダーを継承する
			info.order = _objList[transIndex].absolute;
		}
		with(_objList[index]){
			elm.file = info.file.toUpperCase();

			.envToneEnable = true;	//環境トーンの影響を受ける

			.setup(elm);
			.info.copy(info);

			//通常見えない部分をトリミング
			if(elm.fullsize === void && IsRegistAdvObjInfo(elm.file)){
				var size = ADVOBJ_INFO[elm.file].guidey + BUSTUP_TRIMMING_SIZE;
				if(._spr.height > size){
					._spr.setImageSize(._spr.width, size);
					._spr.setSizeToImageSize();

					.info.trimming = true;
				}
			}

			if(preFocus != -1) .focus(preFocus);
			if(preTone != "") .tone(preTone);

			.kind |= ADVOBJ_BUSTUP;
			if(GetElm(elm.free, true, false))
				.kind |= ADVOBJ_BUSTUP_FREE;
			.relate = info.relate;

			if(GetElm(elm.type, "").toLowerCase() == "screen")
				.kind |= ADVOBJ_SCREEN;

			if(.kind & ADVOBJ_SCREEN){
				.setCenter(.imageWidth\2, .imageHeight\2);
			}else if(info.center.x == ADVOBJ_NULL){
				.setCenter(.imageWidth\2, .imageHeight - 50);
			}else{
				.setCenter(info.center.x, info.center.y);
			}

			@if(__DEBUGMODE__)
				if(debug.tglSupExp.state){
					var text = CG_INFO[info.file.substring(0, 7)];
					if(text === void) text = info.file;

					var texts = text.split("/");
					var y = info.center.y+70;
					for(var i=0;i<texts.count;i++){
						.font.height = 18 + random(3);
						var hintWidth = .font.getTextWidth(texts[i]);
						.drawText(info.center.x - hintWidth \ 2, y, texts[i], RGB(127+random(128), 127+random(128), 127+random(128)), 255, true, 1024, 0x9, 2, 1, 1);
						y += .font.height + 2;
					}
				}
			@endif

			var fAppointPos = false;
			var pos = new Point(0, 0, 50);
			if(elm.pos !== void){
				pos = PointStrToNum(elm.pos);
				fAppointPos = true;
			}
			if(elm.x !== void){
				pos.x = int(elm.x);
				fAppointPos = true;
			}
			if(elm.y !== void){
				pos.y = int(elm.y);
				fAppointPos = true;
			}
			if(elm.z !== void){
				pos.z = int(elm.z);
				fAppointPos = true;
			}else{
				pos.z = info.zOrder;
			}
			preWorld.z = pos.z;

			if(elm.wpos !== void){
				pos = PointStrToNum(elm.wpos);
				fAppointPos = true;
			}

			if(.kind & ADVOBJ_BUSTUP_FREE) fAppointPos = false;

			//スクリーン座標指定をワールド座標に変換
			//var tempY = pos.y;	//Y座標保存
			//pos = screenToWorld(_camera_pos, pos);
			//pos.y = tempY;	//Y座標はアイラインを合わせる必要があるから元に戻す。

			var fActivationChange = false;		//真ならトランジションを使わずアクティベーションで個別に処理する

			//全画面更新の場合はアクティベーションで処理
			if(_update & UPDATE_CG) fActivationChange = true;

			var trans = 255;
			if(elm.trans !== void){
				preTrans = trans = int(elm.trans);
				fActivationChange = true;
			}
			var time = 500;
			if(elm.time !== void)
				time = int(elm.time);
			if(isSkip())
				time = 0;

			//更新時間を演出速度設定で補正
			time = ReviceEffectSpeed(time);

			if(fAppointPos == false && newObject == false){
			//座標指定が無く、かつ既存オブジェクトの場合は以前の座標を引き継ぐ
				.setWorldPos(preWorld.x, preWorld.y, preWorld.z);
			}else{
			//座標指定があったので、そちらを使う
				.setWorldPos(pos.x, pos.y, pos.z);
			}

			if(fAppointPos){							//座標指定があり、
				if(elm.tempPosition === void)			//tempPositionタグがなければ、
					_fBustupAutoPositioning = false;	//バストアップの自動位置調整を無効に。
				else
					._tempPositioning = true;			//仮位置設定：自動位置調整の影響を受けない
			}

			.setBasePos(WINDOW_CENTER_X, WINDOW_CENTER_Y);

			var order = info.order;
			if(elm.order !== void)
				.info.order = order = elm.order;

			if(.absolute != order) fActivationChange = true;
			.absolute = order;

			if(preTrans == -1)
				.opacity = trans;
			else
				.opacity = preTrans;

			.onPaint();				//一回レイヤを更新する

			if(elm.blur !== void)
				.doBoxBlur(int(elm.blur), int(elm.blur));

			if(newObject){
				var pos = worldToScreen(_camera_pos, .getWorldPos());
				.setPos(pos.x, pos.y);
				.visible = true;
				if((_update & check) == check || time == 0){
					.opacity = trans;
				}else{
					.opacity = 0;
					.setBlendingEnvelope(trans);
					.beginActivation(time);
				}
			}else{
				if(time == 0){
					.visible = true;
					removeADVObject(_objList[transIndex].info.id);
				}else{
					if(fActivationChange){
					//オーダーに変更、または全画面更新の場合は別々に処理する。
						_objList[transIndex].setBlendingEnvelope(0);
						_objList[transIndex].beginActivation(time);
						.visible = true;
						.opacity = 0;
						.setBlendingEnvelope(trans);
						.beginActivation(time);
					}else{
						_objList[transIndex].beginTransition("crossfade", true, _objList[index], %[time:time]);
					}
				}
			}

			.setTransitionCompleteCall(transitionComplete);

			invalidate pos;
		}
		if(elm.action !== void){
			elm.id = info.id;
			asyncAction(elm);
		}

		invalidate info;
		_update |= UPDATE_BUSTUP;
	}

	function clearChar(elm=%[]){
	//elm.id
		if(_update & UPDATE_CG && !(_update & UPDATE_FOCUS)){
		//全画面更新の時はバストアップをそのまま消す
			_fBustupAutoPositioning = true;
			removeADVObject(ADVOBJ_BUSTUP);
			removeADVObject(ADVOBJ_BUSTUP|ADVOBJ_BUSTUP_FREE);
			removeADVObject(ADVOBJ_BUSTUP|ADVOBJ_SCREEN);
			removeADVObject(ADVOBJ_BUSTUP|ADVOBJ_BUSTUP_FREE|ADVOBJ_SCREEN);
		}else{
		//バストアップ更新の時はフェードアウトさせる
			var time = int GetElm(elm.time, 500);
			if(isSkip()) time = 0;

			//更新時間を演出速度設定で補正
			time = ReviceEffectSpeed(time);

			if(elm.id === void)
				elm.id = -1;

			if(elm.id != -1){
			//個別消去
				var index = getADVObjectIndex(elm.id);
				if(index != -1){
					with(_objList[index]){
						if(time == 0){
							removeADVObject(.info.id);
						}else if(.id.indexOf("-trans") == -1){
							if(.isEmotion()) .resetEmotion();
							.id = .id + "-trans";	//IDを変更する
							.setBlendingEnvelope(0);
							.beginActivation(time);
							.destroy = ADVOBJ_DESTROY_WAIT;
						}
					}
				}
			}else{
			//全消去
				_fBustupAutoPositioning = true;
				for(var i=_objList.count-1;i>=0;i--){
					with(_objList[i]){
						if(.kind & ADVOBJ_BUSTUP){
							if(time == 0){
								removeADVObject(.info.id);
							}else if(.id.indexOf("-trans") == -1){
								if(.isEmotion()) .resetEmotion();
								.id = .id + "-trans";	//IDを変更する
								.setBlendingEnvelope(0);
								.beginActivation(time);
								.destroy = ADVOBJ_DESTROY_WAIT;
							}
						}
					}
				}
			}
		}
		_update |= UPDATE_BUSTUP;
	}

	function cutin(elm){
	//elm.file
	//elm.pos
	//elm.action
		//if(elm.file === void) return;

		if(elm.hide !== void){
			_cutinParam.file = "";
			invalidate _cutin;
			return;
		}
		if(elm.file !== void){
			invalidate _cutin;
			_cutin = new ADVObject(window, this);
			with(_cutin){
				.adv = this;
				SetupSd(elm.file);	//ただのフラグ立て
				.setup(elm);
				.kind = ADVOBJ_SCREEN;
				.absolute = ADVLAYER_CUTIN;
				.setCenter(.width/2, .height/2);
				var pos = new Point(0, 0, 0);
				if(elm.pos !== void){
					pos = PointStrToNum(elm.pos);
					_cutinParam.pos = elm.pos;
				}
				.setPos(CUTIN_X + pos.x, CUTIN_Y + pos.y);
				.visible = true;
			}
			_cutinParam.file = elm.file;
		}
		if(elm.action !== void){
			//アクション中なら終了させる
			if(_actionList.isAction(_cutin))
				_actionList.stopAction(_cutin);

			elm.id = "カットイン";
			if(elm.move !== void || elm.mx !== void || elm.my !== void){
				if(elm.move !== void){
					var move = PointStrToNum(elm.move);
					elm.mx = move.x;
					elm.my = move.y;
				}
				if(elm.mx === void)	elm.mx = 0;
				else				elm.mx = int(elm.mx);
				if(elm.my === void)	elm.my = 0;
				else				elm.my = int(elm.my);

				elm.mx += _cutin.left;
				elm.my += _cutin.top;

				_cutinParam.pos = PointNumToStr(elm.mx-CUTIN_X, elm.my-CUTIN_Y);
			}

			if(elm.accel === void) elm.accel = 2;
			asyncAction(elm);
		}
	}

	//画面フラッシュ
	function flashEnter(elm){
		var color = GetElm(elm.color, "WHITE");
		var enter = int GetElm(elm.enter, 200);
		enter = ReviceEffectSpeed(enter);
		_flashLeave = int GetElm(elm.leave, 200);
		_flashLeave = ReviceEffectSpeed(_flashLeave);
		if(CONFIG.screenEffect == 0){
			enter = 0;
			_flashLeave = 0;
		}

		var center = GetElm(elm.center, "%d,%d".sprintf(WINDOW_CENTER_X, WINDOW_CENTER_Y));

		if(isSkip()){
			if(enter != 0) enter = 1;
			if(_flashLeave != 0) _flashLeave = 1;
		}

		invalidate _sprFlash;
		_sprFlash = new Sprite(window, this);
		with(_sprFlash){
			var temp = new global.Layer(window, this);
			if(
				Storages.isExistentStorage(color + ".png") ||
				Storages.isExistentStorage(color + ".tlg")
			){
				temp.loadImages(color);
				temp.setSizeToImageSize();
			}else{
				temp.setImageSize(WINDOW_WIDTH, WINDOW_HEIGHT);
				temp.setSizeToImageSize();

				FillRect(temp, color);
			}

			var pos = PointStrToNum(center);
			.setImageSize(WINDOW_WIDTH, WINDOW_HEIGHT);
			.setSizeToImageSize();

			var type = stFastLinear;
			.stretchCopy(0, 0, pos.x, pos.y, temp, 0, 0, temp.width\2, temp.height\2, type);
			.stretchCopy(pos.x, 0, .width-pos.x, pos.y, temp, temp.width\2, 0, temp.width\2, temp.height\2, type);
			.stretchCopy(0, pos.y, pos.x, .height-pos.y, temp, 0, temp.height\2, temp.width\2, temp.height\2, type);
			.stretchCopy(pos.x, pos.y, .width-pos.x, .height-pos.y, temp, temp.width\2, temp.height\2, temp.width\2, temp.height\2, type);
			invalidate pos;

			invalidate temp;
			color = color.toUpperCase();
			.hitType = htMask;
			.hitThreshold = 256;
			.opacity = 0;
			.absolute = ADVLAYER_FLASH;
			.setBlendingEnvelope(255);
			.visible = true;
			.setTransitionCompleteCall(flashLeave, true);
			.beginActivation(enter);

			if(elm.add !== void) _sprFlash.type = ltAdditive;
			if(elm.sub !== void) _sprFlash.type = ltSubtractive;
		}
	}
	function flashLeave(){
		if(!isvalid this) return;
		if(_sprFlash === void) return;

		update(%[flush:1, time:0]);
		with(_sprFlash){
			.setTransitionCompleteCall(flashEnd, true);
			.setBlendingEnvelope(0);
			.beginActivation(_flashLeave);
		}

		_scCtrl.trigger("flash_end");
	}
	function flashEnd(){
		if(!isvalid this) return;
		if(_sprFlash === void) return;

		_sprFlash.setTransitionCompleteCall();
		_sprFlash.visible = false;
		invalidate _sprFlash;
		_sprFlash = void;

		//flashLeaveを通過しない場合があるから、ここでもトリガーを引く
		_scCtrl.trigger("flash_end");
	}

	function tone(elm){
		if(elm.id === void && elm.once === void && elm.all === void){
		//elm.idがないということは、トーン解除
			for(var i=_objList.count-1;i>=0;i--){
				if(_objList[i].kind != ADVOBJ_SCREEN && _objList[i]._tone != "normal"){
					_objList[i].tone("normal");
				}
			}
		}else{
			if(elm.all !== void){
			//全て
				for(var i=_objList.count-1;i>=0;i--){
					if(_objList[i].kind != ADVOBJ_SCREEN){
						_objList[i].tone(elm.type);
					}
				}
			}else if(elm.id !== void){
			//指定オブジェクト
				for(var i=_objList.count-1;i>=0;i--){
					if(_objList[i].kind != ADVOBJ_SCREEN && _objList[i].id == elm.id){
						_objList[i].tone(elm.type);
					}
				}
			}
		}
	}

	function focus(elm){
		if(elm.id === void && elm.once === void && elm.all === void){
		//elm.id, elm.once, elm.allがないということは、フォーカス解除
			for(var i=_objList.count-1;i>=0;i--){
				if(_objList[i].kind != ADVOBJ_SCREEN && _objList[i].id != elm.id){
					_objList[i].focus(0);
				}
			}
		}else{
			elm.depth = int GetElm(elm.depth, 4);

			if(elm.all !== void){
			//全て
				for(var i=_objList.count-1;i>=0;i--){
					_objList[i].focus(elm.depth);
				}
			}else if(elm.id !== void){
			//指定オブジェクト以外
				for(var i=_objList.count-1;i>=0;i--){
					if(_objList[i].kind != ADVOBJ_SCREEN && _objList[i].id != elm.id && _objList[i].id != elm.id+"-trans"){
						_objList[i].focus(elm.depth);
					}else{
						_objList[i].focus(0);
					}
				}
			}else if(elm.once !== void){
			//指定オブジェクトのみ
				for(var i=_objList.count-1;i>=0;i--){
					if(_objList[i].kind != ADVOBJ_SCREEN && _objList[i].id == elm.once){
						_objList[i].focus(elm.depth);
					}else{
						_objList[i].focus(0);
					}
				}
			}
		}

		_update |= UPDATE_CG | UPDATE_FOCUS;
	}

	function requestUpdateCg(){
		_update |= UPDATE_CG;
	}

	function update(elm=%[]){
		if(!_update) return;

		//省略パラメータ調整
		elm.time = int GetElm(elm.time, 500);
		elm.transition = GetElm(elm.transition, "crossfade");
		elm.rule = GetElm(elm.rule, "universal");

		if(isSkip())
			elm.time = 0;
		if(_fLoad)
			elm.time = 0;
		if(CONFIG.screenEffect == 0)
			elm.time = 0;

		//更新時間を演出速度設定で補正
		elm.time = ReviceEffectSpeed(elm.time);

		if(elm.flush === void) elm.flush = 0;
		if(elm.time <= 0) elm.flush = 1;

		if(_sprTrans.isTransition()){
		//まだ前のトランジッションが終了していないなら終了させる。
			transitionComplete(_sprTrans);
		}
		for(var i=0;i<_objList.count;i++){
			if(_objList[i].isActivation()) _objList[i].flushActivation();
			if(_objList[i].isTransition()) _objList[i].stopTransition();
		}

		//現在の場面をコピー
		if(_update & UPDATE_CG){
			hasImage = true;
			_sprTrans.piledCopy(0, 0, this, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
			hasImage = false;
			_sprTrans.visible = true;
		}

		//カメラ移動中の場合は、移動を完了させる。
		if(_update & UPDATE_CG && _fAction){
			flushMoveCamera();
		}

		//オーダーを前処理、後処理に分ける
		var preOrder = [];
		var postOrder = [];
		var lastOrder = [];
		separateOrder(_orderList, preOrder, postOrder, lastOrder);

		processOrder(preOrder, elm);

		if(_fBustupAutoPositioning){
		//バストアップの自動位置調整
			autoPositioning(elm.flush);
		}

		processOrder(postOrder, elm);

		//イベントカメラ無効かつ、イベントＣＧかつ、
		//指定ファイルがＬサイズの時
		if(CONFIG.eventCamera == 0 && _eventSceneSizeL)
			eventCamera(0);
		else
			eventCamera(1);

		putCameraViewObject(_camera_pos);

		processOrder(lastOrder, elm);

		//オーダーリストクリア
		clearOrderList();
		invalidate preOrder;
		invalidate postOrder;
		invalidate lastOrder;

		if(_update & UPDATE_CG){
			if(elm.transition == "crossfade"){
				_sprTrans.beginTransition("crossfade", true, this, elm);
			}else if(elm.transition == "scroll"){
				var param = %[];
				switch(elm.to){
				case   "left": param.from = sttRight; break;
				case  "right": param.from = sttLeft; break;
				case    "top": param.from = sttBottom; break;
				case "bottom": param.from = sttTop; break;
				}
				switch(elm.stay){
				case 'nostay': param.stay = ststNoStay; break;
				case 'stayback': param.stay = ststStaySrc; break;
				case 'stayfore': param.stay = ststStayDest; break;
				default: param.stay = ststNoStay; break;
				}
				param.time = elm.time;
				_sprTrans.beginTransition("scroll", true, this, param);
			}else if(elm.transition == "universal"){
				_sprTrans.beginTransition("universal", true, this, elm);
			}else{
				_sprTrans.beginTransition(elm.transition, true, this, elm);
			}
		}

		//ADVオブジェクトの新規フラグをfalseに
		for(var i=0;i<_objList.count;i++){
			if(_objList[i].fresh) _objList[i].fresh = false;
		}

		_update = 0;
	}

	function autoPositioning(fFlush=false){
		sortADVObjectBustupRelate();
		var autoPos = getAutoPosition(countADVObjBustup(true));

		var iPos = 0;
		for(var i=0;i<_objList.count;i++){
			with(_objList[i]){
				if(.kind & ADVOBJ_BUSTUP_FREE) continue;
				if(.kind & ADVOBJ_BUSTUP && .destroy == ADVOBJ_DESTROY_NONE){
					var pos = .getWorldPos();

					if(!._tempPositioning)
						.setWorldPos(autoPos[iPos], pos.y, pos.z);
					iPos++;

					._tempPositioning = false;

					var seq = _actionList.sequence(_objList[i]);
					if(seq !== void) seq.refreshInit();
				}
			}
		}
	}

	function getAutoPosition(num){
		var BASE_POS = [
			-500, /*  0          */
			-500, /*  1 画面左端 */
			-400, /*  2          */
			-300, /*  3          */
			-200, /*  4          */
			-100, /*  5          */
			   0, /*  6 画面中央 */
			 100, /*  7          */
			 200, /*  8          */
			 300, /*  9          */
			 400, /* 10          */
			 500  /* 11 画面右端 */
		];

		var pos = [];
		var indent;
		switch(num){
		case 1:  
			pos.adds(BASE_POS[6]);
			return pos;
		case 2:
			pos.adds(BASE_POS[4], BASE_POS[8]);
			return pos;
		case 3:
			pos.adds(BASE_POS[3], BASE_POS[6], BASE_POS[9]);
			return pos;
		case 4:
			pos.adds(BASE_POS[3], BASE_POS[5], BASE_POS[7], BASE_POS[9]);
			return pos;
		case 5:
			pos.adds(BASE_POS[2], BASE_POS[4], BASE_POS[6], BASE_POS[8], BASE_POS[10]);
			return pos;
		default: indent=175; break;
		}
		var startX = - ((num-1) * indent)/2;

		for(var i=0;i<num;i++){
			pos[i] = startX + indent * i;
		}

		return pos;
	}

	//アクション
	function asyncAction(elm, ignoreSkip=false){
		//本体
		var index  = getADVObjectIndex(elm.id, true);
		//消えかけているものを捕捉
		var index_ = getADVObjectIndex(elm.id+"-trans", true);

		if(index != -1 || index_ != -1){
		//ADVオブジェクト
			elm.world = 1;
		}else if(elm.id == "メッセージ"){
			elm.target = _msg;
		}else if(elm.id == "カメラ"){
			elm.target = _camera_pos;
			//カメラが移動中なら止める
			if(_fCamera_move) flushMoveCamera();

			//if(CONFIG.eventCamera == 0 && _eventSceneSizeL) elm.cycle = 0;
		}else if(elm.id == "フェイス"){
			elm.target = _msg._face._face;
		}else if(elm.id == "カットイン"){
			elm.target = _cutin;
		}else{
//			return;
		}

		elm.startTime = _actionTimeKeeper.now();

		elm.cycle = int GetElm(elm.cycle, 500);
		var fFlush = GetElm(elm.flush, true, false);

		var fAction = false;
		if(elm.target !== void){
			_actionList.add(elm, (isSkip() && !ignoreSkip && elm.count != -1));
			fAction = true;
		}
		if(index != -1){
			elm.target = _objList[index];
			_actionList.add(elm, (isSkip() && !ignoreSkip && elm.count != -1));
			fAction = true;
		}
		if(index_ != -1){
			elm.target = _objList[index_];
			_actionList.add(elm, (isSkip() && !ignoreSkip && elm.count != -1));
			fAction = true;
		}

		//移動系アクションは自動位置調整無効に。
		//ただしフェードアウト系は無視
		if(elm.world !== void){
			switch(elm.action){
			case "ActionAdvMove" :
			case "ActionAdvMoveWave" :
			case "ActionAdvMoveFadeIn" :
			case "ActionAdvMoveWaveFadeIn" :
			//case "ActionAdvMoveFadeOut" :
			//case "ActionAdvMoveWaveFadeOut" :
				var obj = getADVObjectObject(elm.id);
				if(obj == -1){
					_fBustupAutoPositioning = false;			//自動位置調整を無効に。
				}else{
					//フリーオブジェクトでないなら
					if(!(obj.kind & ADVOBJ_BUSTUP_FREE))
						_fBustupAutoPositioning = false;			//自動位置調整を無効に。
				}
				break;
			}
		}

		if(fAction) startAction();
		if(fAction && (fFlush || elm.cycle == 0)) flushAction(elm.target);
	}

	function stopAsyncAction(elm){
		var target = null;
		if(getADVObjectIndex(elm.id) != -1){
			target = _objList[getADVObjectIndex(elm.id)];
		}else if(elm.id == "メッセージ"){
			target = _msg;
		}else if(elm.id == "カメラ"){
			target = _camera_pos;
		}else if(elm.id == "フェイス"){
			target = _msg._sprFace;
		}else if(elm.id == "カットイン"){
			target = _cutin;
		}

		_actionList.stopAction(target);
	}

	function flushAction(target){
		if(_actionList.isAction(target)){
			_actionList.stopAction(target);
		}
	}

	function emotion(elm){
		//本体
		var index  = getADVObjectIndex(elm.id, true);
		//消えかけているものを捕捉
		var index_ = getADVObjectIndex(elm.id+"-trans", true);

		var obj;
		if(index != -1){
			obj = _objList[index];
		}else if(index_ != -1){
			obj = _objList[index_];
		}else{
			return;
		}

		var info = obj.info;

		with(elm){
			.baseRot = 0;
			.baseAbs = obj._spr.absolute + 1;
		}
		obj.emotion(elm.type, elm);
	}
	function stopEmotion(elm){
		//本体
		var index  = getADVObjectIndex(elm.id, true);
		//消えかけているものを捕捉
		var index_ = getADVObjectIndex(elm.id+"-trans", true);

		if(index != -1) _objList[index].resetEmotion();
		if(index_ != -1) _objList[index_].resetEmotion();
	}

	function onEndAction(target){
		if(_actionList.isAction(target) && _actionWaitTarget == target){
			_scCtrl.trigger("action_end");
			_actionWaitTarget = null;
		}
	}

	function eyeCatch(elm){
		//音関係停止
		var fBgmStop = int GetElm(elm.bgmstop, 1);
		if(fBgmStop) StopBgm(1000);
		StopSe();
		StopEnvSe("", 1000);
		StopVoice();
		StopBgv();

		if(isSkip()) return;

		elm.type = GetElm(elm.type, "A");

		hide();

		switch(elm.type.toUpperCase()){
		case "DATE" : 
			_eyeCatch = new EyeCatchDate(window, window.baseLayer, this, elm);
			break;
		default : 
			_eyeCatch = new EyeCatchTime(window, window.baseLayer, this, elm);
			break;
		}
	}
	function eyeCatchDelete(){
		_scCtrl.trigger("eyecatch_end");

		if(!isvalid _eyeCatch) return;
		if(_eyeCatch === null) return;

		invalidate _eyeCatch;
		_eyeCatch = null;
	}

	function messageFrame(elm){
		if(isSkip())
			elm.time = 0;
		else
			elm.time = ReviceEffectSpeed(300);

		elm.type = GetElm(elm.type, "");
		var type = 0;
		switch(elm.type){
		case "1"      : type = 1; break;

		case "穹"     : type = 2; break;
		case "奈緒"   : type = 3; break;
		case "瑛"     : type = 4; break;
		case "一葉"   : type = 5; break;
		case "初佳"   : type = 6; break;
		case "亮平"   : type = 7; break;
		case "やひろ" : type = 8; break;
		case "梢"     : type = 9; break;

		case "ノベル" : type = 10; break;

		case "0" : 
		default : type = 0; break;
		}

		_msg.setType(type, elm.time);
	}

	function cinema(elm=%[]){
		if(isSkip()) elm.time = 0;

		elm.type = int GetElm(elm.type, 0);
		elm.fade = int GetElm(elm.fade, 500);
		elm.trans = int GetElm(elm.trans, 255);
		elm.color = GetElm(elm.color, "black");

		_cinema.set(elm.type, elm.fade, elm.color, elm.trans);
	}

	function show(fade=300){
		if(!_msg.isShow() && _advHide == false){
			_msg.show(fade);

			if(_startSelect){
				for(var i=0;i<_selectBtn.count;i++)
					_selectBtn[i].btn.hitThreshold = 0;
				_selectBase.setBlendingEnvelope(255);
				_selectBase.beginActivation(fade);
			}
		}
	}
	function hide(fade=300, fAdvHide=false){
		_advHide = fAdvHide;
		if(_msg.isShow()){
			_msg.hide(fade, fAdvHide);

			if(_startSelect){
				for(var i=0;i<_selectBtn.count;i++)
					_selectBtn[i].btn.hitThreshold = 256;
				_selectBase.setBlendingEnvelope(0);
				_selectBase.beginActivation(fade);
			}
		}
	}
	function moveWindow(x=0, y=0){
		if(_msg.isShow() && !isSkip())
			_msg.movePos(x, y);
		else
			_msg.movePos(x, y, 0);

		_msgX = x;
		_msgY = y;
	}

	function isShow(){
		return _msg.isShow();
	}

	function delay(elm){
	//elm.time
		if(!_update) return;
	}

	function addSelect(elm){
		var temp = %[];
		(Dictionary.assignStruct incontextof temp)(elm);
		_select.add(temp);
	}
	function startSelect(elm){
		if(_select.count == 0) return false;

		SetParam(SELECTTERMINATE_FLAG, elm.terminate !== void);

		//オートセーブ仮保存
		_autoSave.init();
		_autoSave.set(this, true, false, false);

		if(!_fLoad) _hitretNum++;

		if(!_fLoad){
			if(_jumpState){
			//ジャンプ処理中は無視する
			}else if(elm.finish_type1 !== void){
			//フェラ射精選択
				if(CONFIG.selectFix){
					decideSelect(CONFIG.selectFix_finish1 ? 1 : 0);
					return false;
				}
			}else if(elm.finish_type2 !== void){
			//ＳＥＸ射精選択
				if(CONFIG.selectFix){
					decideSelect(CONFIG.selectFix_finish2 ? 1 : 0);
					return false;
				}
			}
		}

		//スキップ解除設定なら解除
		if(CONFIG.lockSkip == 0 && isSkip())
			skip(false, false, true);

		//オート解除設定なら解除
		if(CONFIG.lockAuto == 0 && isAuto())
			auto(false, true);

		_quickSave = false;

		_startSelect = true;

		if(_fLoad){
			loadEnd(true);
		}else{
			if(_update) update();
			if(_orderList.count) processOrder();
		}

		//オートセーブ仮保存
		_autoSave.set(this, true, false, false);

		_selectBase.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
		_selectBase.setPos(0, 0);

		var hint = %[
		    穹 : 0, 
		  奈緒 : 1, 
		    瑛 : 2, 
		  一葉 : 3, 
		  初佳 : 4, 
		やひろ : 5, 
		    梢 : 6
		];

		_selectHintIconImage = new global.Layer(window, this);
		with(_selectHintIconImage){
			.loadImages("FRM_0152");
			.setSizeToImageSize();
		}

		_selectBtn = [];
		for(var i=0;i<_select.count;i++){
			_selectBtn[i] = %[];
			_selectBtn[i].btn = new Button(win, _selectBase);
			with(_selectBtn[i].btn){
				.create("FRM_0151", 2);
				if(_select[i].invalid !== void) .valid = false;
				if(_select[i].flag !== void){
					if(int(_select[i].flag) != 0 &&
					   !ChkFlagOn(int(_select[i].flag))){
							.valid = false;
					}
				}
			}
			_selectBtn[i].mess = new global.Layer(win, _selectBtn[i].btn);
			with(_selectBtn[i].mess){
				.setSize(_selectBtn[i].btn.width, _selectBtn[i].btn.height);
				.font.face = GetFontFace("30");
				var ref = PRFONT_DIC[.font.face];
				.hitType = htMask;
				.hitThreshold = 256;
				var e = DEF_FONT_STYLE;
				var mx = 32;
				var my = 26 - ref.height \ 2 + ref.ratio;
				var text = _select[i].text;
				if(_select[i].invalid === void){
					.drawText(mx + _selectBtn[i].width * 0, my, text, e.color, e.opa, e.aa, e.shadowlevel, 0x000000, e.shadowwidth, e.shadowx, e.shadowy);
					.drawText(mx + _selectBtn[i].width * 1, my, text, e.color, e.opa, e.aa, e.shadowlevel, 0x000000, e.shadowwidth, e.shadowx, e.shadowy);
				}else{
					.drawText(mx + _selectBtn[i].width * 0, my, text, e.color, 128, e.aa, e.shadowlevel, 0x000000, e.shadowwidth, e.shadowx, e.shadowy);
					.valid = false;
				}

				.visible = true;
			}
			if(_select[i].hint !== void && CountFlagOn(1, 2, 3, 4) == 0){
				var names = _select[i].hint.split(",/");
				_selectBtn[i].hintID = [];
				_selectBtn[i].hintSpr = [];
				for(var j=0;j<names.count;j++){
					_selectBtn[i].hintID[j] = hint[names[j]];
					_selectBtn[i].hintSpr[j] = new global.Sprite(window, _selectBtn[i].btn);
					with(_selectBtn[i].hintSpr[j]){
						.assignImages(_selectHintIconImage);
						.setSize(.imageWidth\5, 40);
						.setImagePos(-(.width * hint[names[j]]), 0);
						.setPos(740-((.width+3)*names.count)+((.width+3)*j), 7);
						.imageTop = 0;
						.hitThreshold = 256;

						.opacity = 0;
						.setBlendingEnvelope(255);
						.setMovingEnvelope(.left+32, .top, .left, .top, 2);
						.beginActivation(300);
						.visible = CONFIG.routeGuide;
					}
				}
			}

			addChainItem(_selectBtn[i].btn);
		}

		if(CONFIG.routeGuide) routeGuideEnable(true);

		var cx = (WINDOW_WIDTH-_selectBtn[0].btn.width)/2;
		var cy = 300 - ((_selectBtn[0].btn.height+4)*_select.count)/2;
		for(var i=0;i<_select.count;i++){
			_selectBtn[i].btn.setPos(cx, cy+(_selectBtn[i].btn.height+4)*i);
			if(_selectBtn[i].sd !== void){
				for(var j=0;j<_selectBtn[i].sd.count;j++){
					var x;
					var y = _selectBtn[i].btn.top+_selectBtn[i].btn.height-_selectBtn[i].sd[j].height;
					if(j%2){
						x = _selectBtn[i].btn.left - _selectBtn[i].sd[j].width\2;
						x -= 48 * (j\2);
					}else{
						x = _selectBtn[i].btn.left+_selectBtn[i].btn.width-_selectBtn[i].sd[j].width \ 2;
						x += 48 * (j\2);
					}
					_selectBtn[i].sd[j].setPos(x, y);
				}
			}
		}

		_selectBase.opacity = 0;
		_selectBase.setBlendingEnvelope(255);
		_selectBase.beginActivation(300);
		_selectBase.visible = true;

		mouseTrackingMode = global.ChainItemBase.MOUSETRACKINGMODE_SEQUENTIAL;

		_selectType = SELECTTYPE_NORMAL;

		return true;
	}
	function endSelect(){
		if(!_startSelect) return;

		_selectBase.visible = false;
		_selectBase.setBlendingEnvelope(0);
		_selectBase.beginActivation(300);

		for(var i=0;i<_selectBtn.count;i++){
			if(_selectBtn[i].hintSpr !== void){
				InvalidateArray(_selectBtn[i].hintSpr);
				invalidate _selectBtn[i].hintSpr;
			}

			(Dictionary.clear incontextof _selectBtn[i])();
		}
		InvalidateArray(_selectBtn);
		_selectBtn.clear();

		removeChainItemAll();

		_select.clear();
		_startSelect = false;
		_selectType = SELECTTYPE_NONE;
		_scCtrl.trigger("select");
	}
	function decideSelect(id, fStack=true){
		_ret_select = id+1;
		_ret_select_str = _select[id].text;
		_logSelect.add(_ret_select);		//ログに記録

		//選択肢をログに保存
		var sel = [];
		sel.assignStruct(_logSelect);
		addLog("■選択肢■", "《" + _ret_select_str + "》が選択されました。", "", %[font:%[size:ADV_FONT_MESS_SIZE], pan:"", newline:0, scenario:_scenario, hitret:_hitretNum, select:sel]);

		if(fStack){
			var temp = [];
			temp.assignStruct(_logSelect);
			_stackSelect.push(%[scenario:_scenario, logCount:_logName.count, hitret:_hitretNum, selectLog:temp, stackCount:_stackSelect.count]);
		}

		//ラベルが設定されているなら、そこにジャンプさせる
		if(_select[id].label !== void){
			try{
				_scCtrl.goToLabel("*" + _select[id].label);
			}catch{
				dm("指定されたラベルが見つかりませんでした : *" + _select[id].label);
			}
		}

		_select.clear();
		_selectType = SELECTTYPE_NONE;
		_scCtrl.trigger("select");
	}

	function routeGuideEnable(flag){
		for(var i=0;i<_select.count;i++){
			if(_selectBtn[i].hintSpr !== void){
				for(var j=0;j<_selectBtn[i].hintSpr.count;j++){
					_selectBtn[i].hintSpr[j].visible = flag;
				}
			}
		}
	}

	//前・前の選択肢へジャンプ
	function jump(type=JUMPSTATE_SELECT_NEXT, param=%[]){
		if(!_hitretState) return;
		if(IsRecollect()) return;

		switch(type){
		case JUMPSTATE_SELECT_NEXT : 
			if(ChkFlagOn(SELECTTERMINATE_FLAG)) return;
			if(isSelect()) return;

			if(CONFIG.confirmWindow[SystemRegister.CONFIRM_SELECTJUMP])
				PlaySystemVoice("次の選択肢へ");

			CallConfirm("次の選択肢へ進みます。", SystemRegister.CONFIRM_SELECTJUMP, jumpNextStart, null);

			break;
		case JUMPSTATE_SELECT_PREV : 
			if(_stackSelect.count == 0) return;

			if(CONFIG.confirmWindow[SystemRegister.CONFIRM_SELECTJUMP])
				PlaySystemVoice("前の選択肢へ");

			CallConfirm("前の選択肢へ戻ります。", SystemRegister.CONFIRM_SELECTJUMP, jumpPrevStart, null);
			break;
		case JUMPSTATE_NORMAL : 
			jumpNormalStart(param);
			break;
		}
	}
	function jumpPrevStart(){
		_jumpState = JUMPSTATE_SELECT_PREV;

		jumpStart(jumpPrevWork);
	}
	function jumpNextStart(){
		_jumpState = JUMPSTATE_SELECT_NEXT;

		jumpStart(jumpNextWork);
	}
	function jumpNormalStart(param){
		_jumpState = JUMPSTATE_NORMAL;

		(Dictionary.assignStruct incontextof _jumpParam)(param);

		jumpStart(jumpNormalWork);
	}
	function jumpStart(func){
		//シナリオ停止
		_scCtrl.wait(%[]);

		_hitretState = false;

		//音関係停止
		if(_jumpState != JUMPSTATE_SELECT_NEXT){
			StopBgm();
			StopEnvSe();
			StopBgv();
		}
		StopVoice();
		StopSe();

		if(IsPlayMovie())
			onStopMovie();

		if(IsStaffRoll())
			StaffRollDelete();

		if(_startSelect) endSelect();

		_cinema.reset();

		if(isSkip()) skip(false);
		if(isAuto()) auto(false);

		hide(0, true);

		_actionList.stopAction(_cutin);
		cutin(%[hide:1]);

		if(_fAction) flushMoveCamera();

		if(_eyeCatch != null) _eyeCatch.close();

		BeginLoad(func);	//ロード処理開始。現在の画面を隠す。
	}
	function jumpScProcess(handle, hitretNum, logSelect=[], tagList=[], fGetTag=false){
		var bufCg = [];
		var bufChar = [];
		var bufAction = [];
		var bufEmotion = [];
		var bufCamera = [];
		var bufBgm = [];
		var bufBgv = [];
		var bufEnvSe = [];
		var bufEnvEffect = [];
		var bufOther = [];
		var tagRun = [];

		var logSelectIndex = 0;

		var autoPosition = false;			//autoPositionが復活
		var autoPositionRelease = false;	//autoPositionが解除された。

		var funcBustupCheck = function(buf=[], srcElm=%[], fMoveBack=false){
			if(buf.count == 0) return;
			var id = srcElm.id;
			var header = srcElm.file;
			if(id === void){
				header = header.toUpperCase().substring(0, 2);
				id = CHAR_DATA[BUID_TO_INDEX[header]].name;
			}
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				var find = false;
				if(buf[i].tagname == "action"){
					continue;
				}else if(buf[i].id !== void){
					find = (buf[i].id == id);
				}else if(buf[i].file !== void){
					find = (buf[i].file.substring(0, 2) == header);
				}
				if(find){
				//同じオブジェクトがあった場合は、内容を上書きする。
					var array = [];
					array.assign(srcElm);	//辞書内容を配列に書き出す。
					for(var a=0;a<array.count;a+=2){
						buf[i][array[a]] = array[a+1];
					}
					if(
						srcElm.x !== void || 
						srcElm.y !== void || 
						srcElm.z !== void){
					//座標指定の適用
						buf[i].x = int GetElm(srcElm.x, 0);
						buf[i].y = int GetElm(srcElm.y, 0);
//						buf[i].z = int GetElm(srcElm.z, 0);
					}

					//orderは引き継がない仕様になっていたので、指定がない場合は初期化する。
					if(srcElm.order === void) buf[i].order = void;

					buf[i].reqErase = false;	//消去予定をキャンセル

					if(fMoveBack){
					//後ろに移動させる
						var temp = %[];
						(Dictionary.assignStruct incontextof temp)(buf[i]);
						buf.erase(i);
						buf.add(temp);
					}

					return true;
				}
			}
			return false;
		};
		var funcActionClear = function(buf=[], id, header){
			if(buf.count == 0) return;
			if(id === void){
				header = header.toUpperCase().substring(0, 2);
				id = CHAR_DATA[BUID_TO_INDEX[header]].name;
			}
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				if(buf[i].tagname != "action") continue;

				//ActionAdvMoveは消すと座標がおかしくなるので残しておく
				if(buf[i].action == "ActionAdvMove"){
//					continue;
				}

				if(buf[i].id.indexOf(id) != -1) buf.erase(i);
			}
		};
		var funcEmotionClear = function(buf=[], id, header){
			if(buf.count == 0) return;
			if(id === void){
				header = header.toUpperCase().substring(0, 2);
				id = CHAR_DATA[BUID_TO_INDEX[header]].name;
			}
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				if(buf[i].tagname != "emotion") continue;
				if(buf[i].id == id) buf.erase(i);
			}
		};
		var funcIsTagname = function(buf=[], tagname){
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				if(buf[i].tagname == tagname) return true;
			}
			return false;
		};
		function funcEraseID(buf=[], id){
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				if(buf[i].id == id) buf.erase(i);
			}
		};
		function funcEraseReqErase(buf=[]){
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				if(buf[i].reqErase) buf.erase(i);
			}
		};
		function funcEraseTag(buf=[], tagname){
			for(var i=buf.count-1;i>=0 && buf.count > 0;i--){
				if(buf[i].tagname == tagname) buf.erase(i);
			}
		};
		var funcBufClear = function(arg*){
			for(var i=0;i<arg.count;i++) arg[i].clear();
		};
		var funcBufGetElm = function(buf=[], id){
			for(var i=0;i<buf.count;i++){
				if(buf[i].id == id) return buf[i];
			}
		};
		var funcCheckEmotion = function(buf=[]){
			var seq = new AnimationSequence();
			for(var i=buf.count-1;i>=0;i--){
				if(buf[i].type == "") continue;
				seq.load(buf[i].type);
				if(seq.checkAttribute() == AnimationSequence.atbVolatile)
					buf.erase(i);
			}
			invalidate seq;
		};

		//自動位置調整が解除された時に、現在指定されているバストアップの座標を確定させる
		var funcAutoPositionClac = function(bufChar=[], custom="", flip=false){
			//listに@char, @enter指定を抽出する
			var list = [];
			for(var i=0;i<bufChar.count;i++){
				if(bufChar[i].free !== void) continue;
				if(bufChar[i].reqErase) continue;
				if(!(bufChar[i].tagname == "char" || bufChar[i].tagname == "enter")) continue;

				var id = GetElm(bufChar[i].id, void);

				var header = bufChar[i].file.toUpperCase().substring(0, 2);
				var index = BUID_TO_INDEX[header];
				if(id === void) id = CHAR_DATA[index].name;
				var relate = int CHAR_DATA[index].relate;

				list.add(%[ id : id, relate : relate , index : i]);
			}

			//位置調整設定があれば、それをセットする。
			var idList = custom.split(",/");
			for(var r=0;r<idList.count;r++){
				for(var i=0;i<list.count;i++){
					if(idList[r] == list[i].id) list[i].relate = r;
				}
			}

			//relate順にlistを並び替える
			var i, j;
			for(i=0;i<list.count-1;i++){
				for(j=i+1;j<list.count;j++){
					if(!flip){
						if(list[i].relate > list[j].relate) list[i] <-> list[j];
					}else{
						if(list[i].relate < list[j].relate) list[i] <-> list[j];
					}
				}
			}

			//順番に立ち位置を指定していく。
			var pos = getAutoPosition(list.count);
			for(var i=0;i<list.count;i++){
				var index = list[i].index;

				if(bufChar[index].x !== void) continue;

				bufChar[index].x = int pos[i];
			}
		};

		var tagIndex = 0;
		var getNextTagFunc;
		if(tagList.count == 0){
			getNextTagFunc = _scCtrl.getNextTag;
		}else{
			getNextTagFunc = function (list, index){return list[index];};
		}

		_face = "";
		_msg.face("show");
		if(!fGetTag) _msg.setType(0, 0);

		var fRead = false;
		var hitretID = -1;
		var fLoop = true;
		var elm;

		//復帰地点まで進める
		while(hitretNum > 0 && fLoop){
			elm = getNextTagFunc(tagList, tagIndex++);
			if(elm === void){
				if(_fPreviewMode)	break;
				else				returnTo(SCENE_TITLE, elm);
				break;
			}

			if(fGetTag){
				var hoge = %[];
				(Dictionary.assign incontextof hoge)(elm);
				tagList.add(hoge);
			}

			switch(elm.tagname){
			//-------------------------------------------------
			case "cg" : 
				if(fGetTag) break;

				funcBufClear(bufCg, bufChar, bufCamera, bufAction, bufEnvEffect);
				autoPosition = false;

				case "tone" : 
				case "focus" : 

				case "cutin" : 

				case "colorout" : 
					if(fGetTag) break;

					elm.time = 0;

					var temp = %[];
					(Dictionary.assignStruct incontextof temp)(elm);
					bufCg.add(temp);
					break;

				case "blackout" : 
				case "whiteout" : 
					if(fGetTag) break;

					//cgと同じクリア処理
					funcBufClear(bufCg, bufChar, bufCamera, bufAction, bufEnvEffect);
					autoPosition = false;

					var temp = %[];
					temp.tagname = "cg";
					temp.file = elm.tagname.toLowerCase()=="blackout"?"BLACK":"WHITE";
					temp.time = 0;
					bufCg.add(temp);
					break;

			case "char" :
				if(fGetTag) break;
				if(elm.file === void || elm.file == "") break;

				funcActionClear(bufAction, elm.id, elm.file);
				funcActionClear(bufCg, elm.id, elm.file);
				funcEmotionClear(bufEmotion, elm.id, elm.file);
				var overwrite = funcBustupCheck(bufChar, elm, true);

				var f = false;
				if(
					elm.x !== void || 
					elm.y !== void || 
					elm.z !== void || 
					elm.pos !== void || 
					elm.wpos !== void
				){
				//位置指定があると自動位置調整が無効になる
					if(elm.free === void){
						autoPositionRelease = autoPosition;
						autoPosition = false;

						f = autoPosition == false && autoPositionRelease == false;
					}

					//座標指定があった場合はbufCharにある対象キャラのアクションを削除
					funcActionClear(bufChar, elm.id, elm.file);
				}

				if(autoPositionRelease || f){
					funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
					autoPositionRelease = false;
				}

				//削除予定フラグが立っているものはここで消す。
				funcEraseReqErase(bufChar);

				if(overwrite) break;

				if(elm.id === void){
					var header = elm.file.toUpperCase().substring(0, 2);
					elm.id = CHAR_DATA[BUID_TO_INDEX[header]].name;
				}

				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				bufChar.add(temp);

				break;

			case "clearchar" : 
			case "leave" : 
				if(fGetTag) break;

				if(elm.tagname == "leave"){
					var e = funcBufGetElm(bufChar, elm.id);
					var f = false;
					if(e === void){
						f = true;
					}else if(e.free === void){
						f = true;
					}
					if(f){
						funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
						autoPosition = false;
					}
				}

				var fErase = false;
				var id = GetElm(elm.id, -1);
				if(id == -1){
					bufChar.clear();
					bufAction.clear();
				}else{
					funcActionClear(bufAction, elm.id);
					funcActionClear(bufCg, elm.id, elm.file);
					funcEmotionClear(bufEmotion, elm.id, elm.file);

					//ここでは対象のBU指定に対して削除予定フラグreqEraseのみ立てる
					//@clearChar以降の@char, @enter指定で自動位置調整が解除された際、
					//現在座標の決定にズレが生じる為。
					for(var i=bufChar.count-1;i>=0;i--){
						if(bufChar[i].reqErase === void) bufChar[i].reqErase = false;

						if(bufChar[i].id !== void){
							var name = NAME_TO_INDEX[id] !== void ? CHAR_DATA[NAME_TO_INDEX[id]].name : id;
							if(name == bufChar[i].id){
								bufChar[i].reqErase = true;		//削除予定フラグ
								fErase = true;
							}
						}else if(bufChar[i].file !== void){
							id = NAME_TO_INDEX[id] !== void ? CHAR_DATA[NAME_TO_INDEX[id]].buid : id;
							if(id == bufChar[i].file.substring(0, 2)){
								bufChar[i].reqErase = true;		//削除予定フラグ
								fErase = true;
							}
						}
					}
				}
				if(!fErase){
					var temp = %[];
					(Dictionary.assignStruct incontextof temp)(elm);
					bufChar.add(temp);
				}
				break;

			case "autoposition" : 
				if(fGetTag) break;

				autoPosition = true;
				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				bufChar.add(temp);
				break;

			case "charrelate" : 
				if(fGetTag) break;

				autoPosition = true;
				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				bufChar.add(temp);
				handle[elm.tagname](elm);
				break;

			case "enter" : 
				if(fGetTag) break;

				if(funcBustupCheck(bufChar, elm)) break;
				funcActionClear(bufAction, elm.id, elm.file);
				funcActionClear(bufCg, elm.id, elm.file);
				funcEmotionClear(bufEmotion, elm.id, elm.file);

				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				temp.flush = true;
				bufChar.add(temp);

				autoPositionRelease = autoPosition;
				autoPosition = false;

				//funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
				if(autoPositionRelease){
					funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
					autoPositionRelease = false;
				}

				//削除予定フラグが立っているものはここで消す。
				funcEraseReqErase(bufChar);

				break;

			//-------------------------------------------------
			case "action" : 
			case "stopaction" : 
				if(fGetTag) break;

				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);

				if(_fPreviewMode){
					temp.cycle = 0;
					temp.flush = true;
				}

				if(temp.action == "ActionAdvMove" || temp.action == "ActionAdvMoveWave"){
					{
					//A "move" B内と同じコードに
						if(temp.left !== void) temp.mx = -int(temp.left);
						else if(temp.right !== void) temp.mx = int(temp.right);
						if(temp.top !== void) temp.my = -int(temp.top);
						else if(temp.bottom !== void) temp.my = int(temp.bottom);
					}

					if(autoPosition){
						funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
						autoPosition = false;
					}

					bufChar.add(temp);
				}else{
					bufAction.add(temp);
					/*
					var count = GetElm(elm.count, 0);
					if(count != -1){
						bufAction.add(temp);
					}else{
						bufCg.add(temp);
					}
					*/
				}

				break;
			case "waitaction" : 
				funcActionClear(bufAction, elm.id);
				funcActionClear(bufCg, elm.id);

				//bufCharにActionAdvMoveがある場合は、立ち位置を確定させてから、
				//ActionAdvMoveの座標をchar, enterに反映
				var f = true;
				for(var i=bufChar.count-1;i>=0;i--){
					if(bufChar[i].action != "ActionAdvMove") continue;

					if(f){
						funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
						autoPosition = false;
						f = false;
					}

					var id = bufChar[i].id;
					var mx = int bufChar[i].mx;
					var my = int bufChar[i].my;

					for(var j=bufChar.count-1;j>=0;j--){
						if(!(bufChar[j].tagname == "char" || bufChar[j].tagname == "enter")) continue;
						if(bufChar[j].id != id) continue;

						var x = int GetElm(bufChar[j].x, 0);
						var y = int GetElm(bufChar[j].y, 0);

						if(bufChar[i].x !== void) bufChar[j].x = int bufChar[i].x;
						if(bufChar[i].y !== void) bufChar[j].y = int bufChar[i].y;
						if(bufChar[i].mx !== void) bufChar[j].x = x + (int bufChar[i].mx);
						if(bufChar[i].my !== void) bufChar[j].y = y + (int bufChar[i].my);

						break;
					}

					bufChar.erase(i);
				}

				break;
			case "move" : 
				if(fGetTag) break;

				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);

				{
				//B "action" A内と同じコードに
					if(temp.left !== void) temp.mx = -int(temp.left);
					else if(temp.right !== void) temp.mx = int(temp.right);
					if(temp.top !== void) temp.my = -int(temp.top);
					else if(temp.bottom !== void) temp.my = int(temp.bottom);
				}

				temp.tagname = "action";		//actionとして登録
				temp.action = "ActionAdvMove";
				temp.cycle = 0;
				temp.flush = true;

				if(autoPosition){
					funcAutoPositionClac(bufChar, _bustupRelateCustom, _fBustupRelateFlip);
					autoPosition = false;
				}

				bufChar.add(temp);

				break;

			//-------------------------------------------------
			case "movecamera" : 
				if(fGetTag) break;

				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				temp.time = 0;
				bufCamera.add(temp);
				break;

			//-------------------------------------------------
			case "hitret" : 
			case "hitwait" : 
				if(fGetTag) break;

				hitretNum--;
				if(hitretNum && _face != "") _face = "";

				//未読部分にきたら止める
				//コンフィグのスキップ設定を反映
				hitretID = GetElm(elm.id, 0);
				fRead = ChkReadFlag(hitretID);
				if(
					_jumpState == JUMPSTATE_SELECT_NEXT && 
					!fRead && 
					CONFIG.readSkip == 1
				){
					fLoop = false;
				}

				if(fLoop && hitretNum > 0) funcCheckEmotion(bufEmotion);

				elm.time = 0;
				elm.flush = true;
				elm.id = 0;
				handle[elm.tagname](elm);
				resetFontElm();

				break;

			//-------------------------------------------------
			case "movewindow" : 
			case "cinema" : 
			case "counter" : 
				if(fGetTag) break;

				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				temp.fade = 0;
				temp.time = 0;
				bufOther.add(temp);
				break;

			//-------------------------------------------------
			case "startselect" : 
				bufAction.clear();

				//handle[elm.tagname](elm);
				//startselectは呼び出さないが_hitretNumだけ加算しておく。
				//decideSelect()時の選択肢ログの調整のため。
				_hitretNum++;

				hitretNum--;

				if(hitretNum <= 0){
				//これでループ抜ける
				}else{
				//まだループ抜けない
					//「前の選択肢へ」のときはスタックに積まないように。
					var fStack = _jumpState == JUMPSTATE_SELECT_PREV ? false : true;
					if(logSelectIndex < logSelect.count) decideSelect(logSelect[logSelectIndex++] - 1, fStack);
				}

				if(_jumpState == JUMPSTATE_SELECT_NEXT) fLoop = false;

				break;

			//-------------------------------------------------
			case "addselect" : 
			case "setparam" : 
			case "addparam" : 
			case "eval" : 
			case "onflag" : 
			case "offflag" : 
			case "clearparam" : 
			case "onglobalflag" : 
			case "offglobalflag" : 
			case "setselect" : 
			case "charrelatecustom" : 
				handle[elm.tagname](elm);
				break;
			//-------------------------------------------------
			case "dm" : 
				dm(elm.text);
				break;
			//-------------------------------------------------
			default : 
				if(fGetTag) tagList.pop();
				break;
			}
			if(_fPreviewMode) continue;

			switch(elm.tagname){
			//-------------------------------------------------
			case "snow" : 
			case "rain" : 
			case "bgscroll" : 
				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				bufEnvEffect.add(temp);
				break;

			//-------------------------------------------------
			case "playbgm" : 
				bufBgm.clear();

				case "stopbgm" : 
				case "fadebgm" : 
				case "changebgmspeed" : 
				case "pausebgm" : 
				case "restartbgm" : 
					var temp = %[];
					(Dictionary.assignStruct incontextof temp)(elm);
					bufBgm.add(temp);
					break;

			//-------------------------------------------------
			case "playbgv" : 
				funcEraseTag(bufBgv, "playbgv");

				case "stopbgv" : 
					var temp = %[];
					(Dictionary.assignStruct incontextof temp)(elm);
					bufBgv.add(temp);
					break;

			//-------------------------------------------------
			case "stopenvse" : 
				if(elm.id === void){
					bufEnvSe.clear();
				}else{
					var id1 = elm.id.toUpperCase();
					for(var i=bufEnvSe.count-1;i>=0;i--){
						if(bufEnvSe[i].tagname != "playenvse") continue;

						var id2 = bufEnvSe[i].id;
						if(id2 === void) id2 = bufEnvSe[i].file;
						id2 = id2.toUpperCase();
						if(id1 == id2) bufEnvSe.erase(i);
					}
				}

			case "playenvse" : 
			case "fadeenvse" : 
				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				bufEnvSe.add(temp);
				break;

			//-------------------------------------------------
			case "emotion" : 
			case "stopemotion" : 
				var temp = %[];
				(Dictionary.assignStruct incontextof temp)(elm);
				bufEmotion.add(temp);
				break;

			//-------------------------------------------------
			case "talk" : 
			case "ch" : 
			case "face" : 
			case "r" : 
			case "font" : 
			case "partmess" : 
			case "ruby" : 
			case "ignorekinsoku" : 
			case "scene" : 
			case "cameraauto" : 
			case "camerafix" : 
			case "selectterminate" : 
			case "canclose" : 
			case "messageframe" : 

			//-------------------------------------------------
			case "change" : 
				elm.time = 0;
				elm.flush = true;
				handle[elm.tagname](elm);
				break;

			//-------------------------------------------------
			case "tologo" : 
			case "totitle" : 
			case "torecollect" : 
			case "terminate" : 
				elm.time = 0;
				elm.flush = true;
				handle[elm.tagname](elm);
				return;
			case "recollect_end" : 
				var ret = handle[elm.tagname](elm);
				if(ret == taghandler_end) return;
				break;
			}

			if(hitretNum > 1){
			//復帰ポイント手前までのカメラ・メッセージ関係の一時アクションを削除する。
			//復帰ポイント手前までの一時アクションを削除する。
				for(var i=bufAction.count-1;i>=0;i--){
//					if(bufAction[i].id == "カメラ" || bufAction[i].id == "メッセージ"){
//						if(bufAction[i].count != -1) bufAction.erase(i);
//					}
					if(bufAction[i].count != -1) bufAction.erase(i);
				}
			}
		}
		if(fGetTag) return;

		//削除予定フラグが立っているものはここで消す。
		funcEraseReqErase(bufChar);

		var buf = [bufCg, bufChar];
		for(var i=0;i<buf.count;i++){
			var ref = buf[i];
			for(var j=0;j<ref.count;j++){
dm(ref[j].tagname, ref[j].file, ref[j].id, ref[j].x, ref[j].y, ref[j].action);
				handle[ref[j].tagname](ref[j]);
			}
		}

		update(%[time:0]);

		if(_fPreviewMode)
			buf = [bufCamera, bufAction, bufOther];
		else
			buf = [bufCamera, bufAction, bufEmotion, bufBgm, bufBgv, bufEnvSe, bufEnvEffect, bufOther];
		for(var i=0;i<buf.count;i++){
			var ref = buf[i];
			for(var j=0;j<ref.count;j++){
//dm(ref[j].tagname, ref[j].id, ref[j].action);
				handle[ref[j].tagname](ref[j]);
			}
		}

		update(%[time:0]);

		if(autoPosition) _fBustupAutoPositioning = true;
		if(_fBustupAutoPositioning){
		//バストアップの自動位置調整
			autoPositioning(true);
			putCameraViewObject(_camera_pos);
		}

		//プレビューモードならここで戻る
		if(_fPreviewMode) return;

		clearMessage();

		var index = countOfLog() - 1;
		while(_logParam[index].newline){index--;}
		while(index < countOfLog()){
			_name = _logName[index];
			_mess = _logMess[index];
			_voice = _logVoice[index];
			_pan = _logParam[index].pan;
			_volume = _logParam[index].volume;
			resetFontElm();
			_fFont = true;
			(Dictionary.assignStruct incontextof _fontElm)(_logParam[index].font);

			var name = _name.split(",/");
			var dispName;
			var trueName;
			if(name.count == 1){
				dispName = name[0];
			}else{
				dispName = name[1];
			}
			trueName = name[0];
			if(hitretID != -1) SetReadFlag(hitretID, true);
			outputMessage(dispName, _mess, _voice, _pan, _volume, true, fRead, trueName, _logParam[index].newline);

			index++;
		}
		_advHide = false;
		show(0);

		return elm;
	}
	function jumpNormalWork(){
		var startTime = System.getTickCount();

		var tempConfigEffectSpeed = sysReg._config.screenEffectSpeed;
		sysReg._config.screenEffectSpeed = 0;
		var info = _logSaveInfo[_jumpParam.scenario];
		var save = new Savedata();
		(Dictionary.assignStruct incontextof save.param)(info);
		save.applyToAdv(this, false, false);
		var startLogCount = info.logCount;
		var hitretNum = _jumpParam.hitret;

		var logSelect = [];
		logSelect.assignStruct(_jumpParam.select);

		//ログを削る
		eraseLogAfter(startLogCount);

		//選択肢スタックを削る
		for(var i=_stackSelect.count;i>info.stackSelect.count;i--)
			_stackSelect.pop();

		//シナリオをチェンジする
		change(_jumpParam.scenario);

		_msg.setType(0, 0);
		_msg.setType(save.param.messageFrame, 0);

		_cinema.reset();
		cinema(%[type:save.param.cinema, fade:0, color:save.param.cinemaColor, trans:save.param.cinemaTrans]);

		var handle = getHandlers();
		var elm = jumpScProcess(handle, hitretNum, logSelect);

		sysReg._config.screenEffectSpeed = tempConfigEffectSpeed;

		if(elm !== void){
			if(elm.tagname == "startselect"){
				handle["startselect"](elm);
				_hitretNum--;		//hitret数調整のため減算
			}
		}

		jumpEnd();
		EndLoad();

		invalidate save;

		playVoice(%[file:_msg._voice, pan:_msg._pan, vol:_msg._volume, config:true]);

		dm("■ジャンプ処理に%d_秒掛かりました".sprintf(System.getTickCount() - startTime));
	}
	function jumpPrevWork(){
		var startTime = System.getTickCount();

		var tempConfigEffectSpeed = sysReg._config.screenEffectSpeed;
		sysReg._config.screenEffectSpeed = 0;
		var sel = _stackSelect.pop();
		var info = _logSaveInfo[sel.scenario];
		var save = new Savedata();
		(Dictionary.assignStruct incontextof save.param)(info);
		save.applyToAdv(this, false, false);
		var startLogCount = info.logCount;
		var hitretNum = sel.hitret;

		var logSelect = [];
		logSelect.assignStruct(sel.selectLog);
		logSelect.pop();

		//ログを削る
		eraseLogAfter(startLogCount);

		//シナリオをチェンジする
		change(sel.scenario);

		_msg.setType(0, 0);
		_msg.setType(save.param.messageFrame, 0);

		_cinema.reset();
		cinema(%[type:save.param.cinema, fade:0, color:save.param.cinemaColor, trans:save.param.cinemaTrans]);

		var handle = getHandlers();
		var elm = jumpScProcess(handle, hitretNum, logSelect);

		sysReg._config.screenEffectSpeed = tempConfigEffectSpeed;

		if(elm !== void){
			if(elm.tagname == "startselect"){
				handle["startselect"](elm);
				_hitretNum--;		//hitret数調整のため減算
			}
		}

		jumpEnd();
		EndLoad();

		invalidate save;

		playVoice(%[file:_msg._voice, pan:_msg._pan, vol:_msg._volume, config:true]);

		dm("■ジャンプ処理に%d_秒掛かりました".sprintf(System.getTickCount() - startTime));
	}
	function jumpNextWork(){
		var startTime = System.getTickCount();

		var tempConfigEffectSpeed = sysReg._config.screenEffectSpeed;
		sysReg._config.screenEffectSpeed = 0;

		var handle = getHandlers();
		var elm = jumpScProcess(handle, 9999999);

		sysReg._config.screenEffectSpeed = tempConfigEffectSpeed;

		if(elm !== void){
			if(elm.tagname == "startselect"){
				handle["startselect"](elm);
				_hitretNum--;		//hitret数調整のため減算
			}
		}

		jumpEnd();
		EndLoad();

		playVoice(%[file:_msg._voice, pan:_msg._pan, vol:_msg._volume, config:true]);

		dm("■ジャンプ処理に%d_秒掛かりました".sprintf(System.getTickCount() - startTime));
	}
	function jumpEnd(){
		_jumpState = JUMPSTATE_NONE;

		//オートセーブ仮保存
		_autoSave.init();
		_autoSave.set(this, true, false, false);
	}
	function jumpPreview(srcAdvObj, scenario="", hitret=0, select=[]){
	//プレビューモードでのみ使える
		if(!_fPreviewMode) return;

		var startTime = System.getTickCount();

		_jumpState = JUMPSTATE_NORMAL;

		var info = srcAdvObj._logSaveInfo[scenario];
		var save = new Savedata();
		(Dictionary.assignStruct incontextof save.param)(info);
		save.applyToAdv(this, false, false);

		var handle = getHandlers();
		SetAdvSceneTemp(this);

		var sel = [];
		if(_previewTag[scenario] === void){
			_previewTag[scenario] = [];
			change(scenario);

			var hitCount;
			if(srcAdvObj._logSelectEOF[scenario] === void){
				sel.assignStruct(select);
				hitCount = hitret;
			}else{
				sel.assignStruct(srcAdvObj._logSelectEOF[scenario]);
				hitCount = 99999;
			}
			jumpScProcess(handle, hitCount, sel, _previewTag[scenario], true);
		}

		_cinema.reset();
		cinema(%[type:save.param.cinema, fade:0, color:save.param.cinemaColor, trans:save.param.cinemaTrans]);

		save.applyToAdv(this, false, false);
		jumpScProcess(handle, hitret, sel, _previewTag[scenario]);

		SetAdvSceneTemp();

		dm("■プレビュー処理に%d_秒掛かりました".sprintf(System.getTickCount() - startTime));

		_jumpState = JUMPSTATE_NONE;
	}

	function countOfStackSelect(){return _stackSelect.count;}
	function isSelectTerminate(){return ChkFlagOn(SELECTTERMINATE_FLAG);}

	function mouseTracking(obj){
		if(!_msg.isShow()) return;

		global.ChainItemBase.mouseTracking(obj);
	}

	function selectDepth(trans){
		for(var i=0;i<_select.count;i++){
			_selectBtn[i].btn.opacity = trans;
		}
	}
	function chkSelect(id){
		return (_ret_select == id);
	}
	function chkSelectStr(strId){
		return (_ret_select_str == strId);
	}
	function isSelect(){
		return _startSelect;
	}

	function initParam(){
		clearParam();
	}
	function clearParam(id=0, num=-1){
		_param.clear(id,num);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function getParam(id){
		return _param.get(id);
	}
	function setParam(id, arg){
		_param.set(id, arg);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function addParam(id, arg){
		_param.set(id, _param.get(id)+arg);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function onFlag(id){
		_param.set(id, 1);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function offFlag(id){
		_param.set(id, 0);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function chkFlagOn(id){
		return (_param.get(id) != 0);
	}
	function chkFlagOff(id){
		return (_param.get(id) == 0);
	}
	function onGlobalFlag(id){
		SetGlobalFlag(id, true);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function offGlobalFlag(id){
		SetGlobalFlag(id, false);
		@if(__DEBUGMODE__)
			debug.paramUpdate();
		@endif
	}
	function onCgFlag(id){
		SetCgFlag(id, true);
	}
	function offCgFlag(id){
		SetCgFlag(id, false);
	}

	function playBgm(elm){
	//elm.file
	//elm.fade
	//elm.pos
	//elm.loop
	//elm.speed
		var fade = int GetElm(elm.fade, 1000);
		if(elm.nonfade !== void) fade = 0;

		var vol = GetElm(elm.vol, 100) / 100.0;
		var pos = int GetElm(elm.pos, 0);
		var speed = real GetElm(elm.speed, 1.0);

		PlayBgm(elm.file, fade, vol, pos, speed);
	}

	function stopBgm(elm){
	//elm.fade
		var fade = int GetElm(elm.fade, 3000);
		if(elm.nonfade !== void) fade = 0;

		StopBgm(fade);
	}

	function changeBgmSpeed(elm){
		var speed = GetElm(elm.speed, 1.0);

		ChangeBgmSpeed(speed);
	}

	function fadeBgm(elm){
	//elm.fade
		var fade = int GetElm(elm.fade, 1000);
		if(elm.nonfade !== void) fade = 0;

		var vol = int GetElm(elm.vol, 100) / 100.0;

		FadeBgm(fade, vol);
	}

	function pauseBgm(){
		PauseBgm();
	}
	function restartBgm(){
		RestartBgm();
	}

	function playSe(elm){
		var vol = int GetElm(elm.vol, 100) / 100.0;
		var pan = int GetElm(elm.pan, 0);

		PlaySe(elm.file.toUpperCase(), vol, 1.0, pan);
	}

	function stopSe(elm=%[]){
		var id = GetElm(elm.id, "");
		var fade = int GetElm(elm.fade, 1000);
		if(elm.nonfade !== void) fade = 0;

		StopSe(id.toUpperCase(), fade);
	}

	function waitSe(elm){
	}

	function playEnvSe(elm=%[]){
	//elm.file
	//elm.fade
	//elm.playID
		var fade = int GetElm(elm.fade, 2000);
		if(elm.nonfade !== void) fade = 0;

		var vol = int GetElm(elm.vol, 100) / 100.0;
		var pan = int GetElm(elm.pan, 0);

		PlayEnvSe(elm.file.toUpperCase(), vol, 1.0, pan, fade);
	}

	function stopEnvSe(elm=%[]){
	//elm.fade
	//elm.playID
		var id = GetElm(elm.id, "");

		var fade = int GetElm(elm.fade, 3000);
		if(elm.nonfade !== void) fade = 0;

		StopEnvSe(id.toUpperCase(), fade);
	}

	function fadeEnvSe(elm){
	//elm.id
	//elm.fade
	//elm.vol
		var id = GetElm(elm.id, "");

		var fade = int GetElm(elm.fade, 1000);
		if(elm.nonfade !== void) fade = 0;

		var vol = int GetElm(elm.vol, 100) / 100.0;

		FadeEnvSe(id, fade, vol);
	}

	function playVoice(elm=%[]){
	//elm.file
	//elm.vol
	//elm.pan
	//elm.config
		var file = GetElm(elm.file, "");
		var pan = GetElm(elm.pan, "0");
		var vol = GetElm(elm.vol, "");
		var fConfig = int GetElm(elm.config, true);

		var voices = file.split(",/");
		var pans = pan.split(",/");
		var vols = vol.split(",/");

		_fPlayVoice = false;
		_fPlayedVoice = false;

		@if(__TRIAL__)
			var i=0;
			for(;i<voices.count;i++){
				if(Storages.isExistentStorage(voices[i] + ".ogg")) break;
			}
			if(i >= voices.count) return;
		@endif

		if(file == "") return;

		_fPlayVoice = true;

		stopVoice();

		for(var i=0;i<voices.count;i++){
			var header = voices[i].substring(0, 2);
			if(CheckPlayVoice(header) || !fConfig){
				var playFile = voices[i];
				@if(__SPECIAL__)
					//お風呂エコーボイス対応
					if(CONFIG.echoVoice && Storages.isExistentStorage(playFile + "_ECH.ogg"))
						playFile += "_ECH";
				@endif

				var pan = 0;
				if(pans.count > i) pan = int(pans[i]);
				var cnfVol = 1.0;
				if(VCID_TO_INDEX[header] !== void)
					cnfVol = CONFIG.voiceDetails[VCID_TO_INDEX[header]].volume;

				var playVol = 1.0;
				if(vols.count > i) playVol = vols[i]==""?1.0:int(vols[i]) / 100.0;

				if(!isSkip()){
					PlayVoice(playFile, playVol, cnfVol, pan, fConfig);

					checkPauseBgv(playFile.substring(0, 3));
				}

				_fPlayedVoice = true;
			}
		}

		@if(__DEBUGMODE__)
			if(_fPlayedVoice){
				_msg.playVoice();
			}
		@endif
	}

	function repeatVoice(elm, fConfig=true){
	//elm.file
	//elm.id
		_fPlayVoice = false;
		stopVoice();
		var vol = 1.0;
		if(VCID_TO_INDEX[header] !== void)
			vol = CONFIG.voiceDetails[VCID_TO_INDEX[header]].volume;
		PlayVoice(elm.file, vol, 0, fConfig);
	}

	function stopVoice(elm=%[]){
		var fade = int GetElm(elm.fade, 0);
		StopVoice(fade);
	}

	function playBgv(elm=%[]){
	//elm.file
	//elm.fade
	//elm.id
		var id = GetElm(elm.id, "");
		var file = GetElm(elm.file, "");
		@if(__SPECIAL__)
			var index = file.indexOf("_ECH");
			if(index != -1) file = file.substring(0, index);
			//お風呂エコーボイス対応
			if(CONFIG.echoVoice && Storages.isExistentStorage(file + "_ECH.ogg"))
				file += "_ECH";
		@endif

		if(id == ""){
			id = file.toUpperCase().substring(0, 2);
			var index = VCID_TO_INDEX[id];
			if(index !== void) id = CHAR_DATA[index].name;
		}

		var fade = int GetElm(elm.fade, 1000);
		if(elm.nonfade !== void) fade = 0;

		var playVol = int GetElm(elm.vol, 100) / 100.0;
		var pan = int GetElm(elm.pan, 0);

		var header = elm.file.substring(0, 2);
		var cnfVol = 1.0;
		if(VCID_TO_INDEX[header] !== void)
			cnfVol = CONFIG.voiceDetails[VCID_TO_INDEX[header]].volumeBgv;

		var mute = CONFIG.muteBgv | CONFIG.voiceDetails[VCID_TO_INDEX[header]].muteBgv;

		StopBgv(id, 0);

		PlayBgv(id, file, playVol, cnfVol, pan, fade, mute);

		var buf = VOICE.buffer;
		for(var i=0;i<buf.count;i++){
			var snd = buf[i];
			checkPauseBgv(snd.id.substring(0, 3));
		}
	}

	function stopBgv(elm=%[]){
	//elm.fade
	//elm.id
		var id = "";
		if(elm.id !== void){
			id = elm.id.toUpperCase().substring(0, 2);
			var index = VCID_TO_INDEX[id];
			if(index !== void)
				id = CHAR_DATA[index].name;
			else
				id = elm.id;
		}

		var fade = int GetElm(elm.fade, 1000);
		if(elm.nonfade !== void) fade = 0;

		StopBgv(id, fade);
	}

	function checkPauseBgv(vcid){
		var index = VCID_TO_INDEX[vcid];
		if(index === void) return;
		var name = CHAR_DATA[index].name;

		var buf = BGV.buffer;
		for(var i=0;i<buf.count;i++){
			var obj = buf[i];
			if(name == obj.id){
				obj.paused = true;
				return;
			}
		}
	}

	function checkRestartBgv(vcid){
		var index = VCID_TO_INDEX[vcid];
		if(index === void) return;
		var name = CHAR_DATA[index].name;

		var buf = BGV.buffer;
		for(var i=0;i<buf.count;i++){
			var obj = buf[i];
			if(name == obj.id){
				if(obj.paused){
					var vol = 100000 * obj.playVolume * obj.configVolume * BGV.volume;
					obj.volume = 0;
					obj.fade(vol, 1000);
					obj.paused = false;
				}
				return;
			}
		}
	}

	function transition(elm){
	//elm.style
	//elm.time
	//elm.rule
	}

	function blackOut(elm=%[]){
	//elm.time
		elm.tagname = "cg";
		elm.file = "BLACK";
		addOrderList(elm);
		_update |= UPDATE_CG;
		update(elm);
	}

	function whiteOut(elm=%[]){
	//elm.time
		elm.tagname = "cg";
		elm.file = "WHITE";
		addOrderList(elm);
		_update |= UPDATE_CG;
		update(elm);
	}

	function colorOut(elm=%[]){
	//elm.col
	//elm.time
		elm.tagname = "cg";
		elm.file = "";
		addOrderList(elm);
		_update |= UPDATE_CG;
		update(elm);
	}

	function wait(elm){
	//elm.time
	}

	function waitBgm(){
	}

	function waitSe(){
	}

	function waitVoice(){
	}

	function waitEnvSe(){
	}

	function waitTransition(){
	}

	function skip(f, fClick=true, fForce=false){
	//fClick : スキップがオンになったときに一度クリックを発生させる
		if(!isShow() && fForce == false) return;

		_msg.skip = (f!=false);	//メッセージスレームに通知
		if(f && fClick){ click(); }
	}

	function isSkip(mode = false){
		if(mode)	//スキップモードのみのチェック
			return (_msg.skip);
		else		//Ctrlキー押下を合わせたチェック
			//return ((_shift&ssCtrl && window.activate) || _msg.skip);
			return ((System.getKeyState(VK_CONTROL) && window.activate) || _msg.skip);
	}

	function searchSkip(strSearch){
	//デバッグ用のサーチスキップ
		_strSearch = strSearch;
		skip(true);
	}

	function auto(f, fSys=false){
		if(!isShow() && !fSys) return;

		_msg.auto = (f!=false);	//メッセージスレームに通知

		var fVoice = VOICE.isPlay();

		fVoice &= _fPlayedVoice;

		if(f && !fVoice){
		//オン　音声が再生されていない
		//クリック
			click();
		}else if(f && fVoice){
		//オン　音声がされている
		//なにもしない
		}else{
		//オフ
		//タイマーストップ
			stopAutoTimer();
		}
	}
	function isAuto(){
		return _msg.auto;
	}
	function onAutoCallback(now){
		if(_msg.isPending() && !_fPlayVoice){
			_autoTimer.interval = 100;
		}else{
			if(_msg.isPending()){
				_msg.flush();
			}
			click();
			stopAutoTimer();
		}
	}

	function isTransition(){
		var ret = false;

		if(_sprTrans.isTransition()) ret = true;

		return ret;
	}

	function isRecollect(id=-1){
		if(id == -1)	return _fRecollect;
		else			return (_fRecollect && (id == _recollectStart));
	}

	function change(sc, label="", fScChange=false){
		//シナリオチェンジのタイミングでGCを動作させておく
		System.doCompact(clIdle);

		@if(__DEBUGMODE__)
			if(!_fPreviewMode)
				win.caption = global.GAME_CAPTION + " : " + sc;
		@endif

		if(fScChange && _scenario != "" && !_fPreviewMode){
			_logSelectEOF[_scenario] = [];
			_logSelectEOF[_scenario].assignStruct(_logSelect);
		}

		_scenario = sc.toUpperCase();
		_label = label;
		if(!_fLoad){
			_logSelect.clear();
			_hitretNum = 0;
		}
		_paramPrev.object().assign(_param.object());

		if(_jumpState != JUMPSTATE_SELECT_PREV){
			//ファイル先頭でのセーブ情報を保存
			var save = new Savedata();
			save.set(this, true, false, false);
			_logSaveInfo[_scenario] = %[];
			(Dictionary.assignStruct incontextof _logSaveInfo[_scenario])(save.param);
			invalidate save;
		}

		_scCtrl.clear();
		@if(__DEBUGMODE__)
			_scCtrl.loadMacro("macro.ks");
		@endif
		_scCtrl.scenarioLoop(sc, label);
	}

	function returnTo(scene, elm=%[]){
		if(elm.submenu !== void){
			switch(elm.submenu.toUpperCase()){
			case "TOP"         : elm.submenu = 0; break;
			case "SHORTSTORY"  : elm.submenu = 1; break;
			case "WEBCONTENTS" : elm.submenu = 2; break;
			case "BONUS"       : elm.submenu = 3; break;
			}
		}
		game.changeScene(scene, true, elm);

		//音関係停止
		StopBgm(GetElm(elm.time, 1000));
		StopSe("", GetElm(elm.time, 1000));
		StopEnvSe("", GetElm(elm.time, 1000));
		StopVoice(GetElm(elm.time, 1000));
		StopBgv("", GetElm(elm.time, 1000));
		endSelect();
		hide(300, true);

		_end = true;
		var temp = CONFIG.screenEffect;
		CONFIG.screenEffect = 1;		//強制オン
		blackOut(%[time:GetElm(elm.time, 2000)]);
		CONFIG.screenEffect = temp;

		//シナリオ止める
		_scCtrl.interrupt = true;
	}

	//履歴関係
	function clearLog(){
		_logName.clear();
		_logMess.clear();
		_logVoice.clear();
		_logParam.clear();
	}
	function addLog(name, mess, voice, param){
		_logName.add(name);
		_logMess.add(mess);
		_logVoice.add(voice);
		_logParam.add(param);
	}
	function eraseLogAfter(count){
		for(var i=_logName.count-1;i>=count;i--){
			_logName.erase(i);
			_logMess.erase(i);
			_logVoice.erase(i);
			_logParam.erase(i);
		}
	}
	function countOfLog(){
		return _logName.count;
	}

	//画面のコピーを作成する
	function screenShot(spr, fFrame=true){
		spr.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

		var fVisibleMsg = _msg.visible;

		var fVisibleInfo;
		if(SPR_INFORMATION != null){
			fVisibleInfo = SPR_INFORMATION.visible;
			SPR_INFORMATION.visible = false;
		}
		var fVisibleConfirm;
		if(SPR_CONFIRM != null){
			fVisibleConfirm = SPR_CONFIRM.visible;
			SPR_CONFIRM.visible = false;
		}

		if(fFrame == false){
			_msg.visible = false;
		}

		window.baseLayer.hasImage = true;
		spr.piledCopy(0, 0, window.baseLayer, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);
		window.baseLayer.hasImage = false;

		_msg.visible = fVisibleMsg;
		if(SPR_INFORMATION != null)
			SPR_INFORMATION.visible = fVisibleInfo;
		if(SPR_CONFIRM != null)
			SPR_CONFIRM.visible = fVisibleConfirm;
	}

	//ロード処理
	//手順：画面隠す→復帰ポイントまで移動→画面構築→画面表示
	function load(filename=""){
		if(filename != ""){
		//セーブファイルをロードする
			_saveData = new Savedata();
			if(_saveData.load(filename) == false) return;
		}else{
		//_saveDataに既に復帰情報が設定されていることを前提に処理を進める
		}

		//シナリオ停止
		_scCtrl.wait(%[]);

		_fLoad = true;
		_hitretState = false;

		//音関係停止
		StopBgm();
		StopSe();
		StopEnvSe();
		StopVoice();
		StopBgv();

		if(IsPlayMovie())
			onStopMovie();

		if(IsStaffRoll())
			StaffRollDelete();

		BeginLoad(this.loadStart);	//ロード処理開始。現在の画面を隠す。
	}

	function loadStart(){
		if(_startSelect) endSelect();

		if(isSkip()) skip(false);
		if(isAuto()) auto(false);

		hide(0, true);

		_actionList.stopAction(_cutin);
		cutin(%[hide:1]);

		if(_fAction)
			flushMoveCamera();

		if(_eyeCatch != null) _eyeCatch.close();

		//BGM
		if(_saveData.param.bgm != ""){
			playBgm(%[file:_saveData.param.bgm, vol:_saveData.param.bgmVol, speed:_saveData.param.bgmSpeed]);
			if(_saveData.param.pauseBgm) pauseBgm();
		}

		//環境音
		var ref = _saveData.param.envSe;
		for(var i=0;i<ref.count;i++){
			playEnvSe(ref[i]);
		}
		var ref = _saveData.param.bgv;
		for(var i=0;i<ref.count;i++){
			playBgv(ref[i]);
		}

		//シナリオを追跡するために、
		//セーブデータの各パラメータをオブジェクトに反映
		_saveData.applyToAdv(this);

		_hitretCnt = _saveData.param.hitret - 1;
		_selectCnt = 0;

		start(_saveData.param.scenario, _saveData.param.label);	//シナリオを復帰ポイントまで移動させる。
	}

	function loadEnd(){
	//復帰ポイントに到達したのでADV画面を構築する。

		//--------------------------------------------------------------------------
		//ＣＧ
		clearChar();
		for(var i=0;i<_saveData.param.advObject.count;i++){
			var file = _saveData.param.advObject[i].file;
			var type = _saveData.param.advObject[i].kind&ADVOBJ_SCREEN?"screen":void;
			var free = _saveData.param.advObject[i].kind&ADVOBJ_BUSTUP_FREE?1:void;
			var id = _saveData.param.advObject[i].id;
			var order = _saveData.param.advObject[i].order;
			var zOrder = _saveData.param.advObject[i].zOrder;
			var relate = _saveData.param.advObject[i].relate;
			var center = _saveData.param.advObject[i].center;
			var fullsize = _saveData.param.advObject[i].trimming?void:1;
			var world = _saveData.param.advObject[i].worldPos;
			var base = _saveData.param.advObject[i].basePos;
			var focus = _saveData.param.advObject[i].focus;
			var tone = _saveData.param.advObject[i].tone;
			var zoom = _saveData.param.advObject[i].zoom;
			var opacity = _saveData.param.advObject[i].opacity;
			var flipLR = _saveData.param.advObject[i].flipLR;
			var flipUD = _saveData.param.advObject[i].flipUD;

			var param = %[file:file, id:id, center:center, type:type, wpos:world, order:order, time:0, focus:focus, tone:tone, trans:opacity, fullsize:fullsize, zoom:zoom, free:free];
			if(flipLR) param.fliplr = 1;
			if(flipUD) param.flipud = 1;

			switch(_saveData.param.advObject[i].kind){
			case ADVOBJ_CG : 
				cg(param);
				//環境トーンを差し替える
				_envTone.assignStruct(_saveData.param.envTone);
				break;
			case ADVOBJ_BUSTUP : 
			case ADVOBJ_BUSTUP|ADVOBJ_BUSTUP_FREE : 
			case ADVOBJ_BUSTUP|ADVOBJ_SCREEN : 
			case ADVOBJ_BUSTUP|ADVOBJ_BUSTUP_FREE|ADVOBJ_SCREEN : 
				char(param);
				break;
			case ADVOBJ_SCREEN : 	break;
			}
		}
		//カットイン
		if(_saveData.param.cutin.file != "")
			cutin(_saveData.param.cutin);

		//シネマ
		_cinema.reset();
		cinema(%[type:_saveData.param.cinema, fade:0, color:_saveData.param.cinemaColor, trans:_saveData.param.cinemaTrans]);

		//カメラ
		if(_saveData.param.camera_move == ""){
			moveCamera(%[pos:_saveData.param.camera, time:0]);
		}else{
			moveCamera(%[pos:_saveData.param.camera_move, time:0]);
		}

		//ロード復帰時は自動位置調整がＯＮであっても
		//セーブデータに指定されている座標でバストアップを表示させる
		_fBustupAutoPositioning = false;

		//_fBustupRelateFlip = false;
		_fBustupRelateFlip = _saveData.param.bustupRelateFlip;
		_bustupRelateCustom = _saveData.param.bustupRelateCustom;

		//--------------------------------------------------------------------------
		//画面更新
		update(%[flush:1]);
		//--------------------------------------------------------------------------

		_autoState = 0;	//オート状態リセット

		//--------------------------------------------------------------------------
		//メッセージ・音声
		var index = countOfLog() - 1;
		_name = _logName[index];
		_mess = _logMess[index];
		_voice = _logVoice[index];
		_pan = _logParam[index].pan;
		_fFont = true;
		(Dictionary.assignStruct incontextof _fontElm)(_logParam[index].font);

		_msg.setType(0, 0);
		_msg.setType(_saveData.param.messageFrame, 0);
		_msgX = _saveData.param.messageX;
		_msgY = _saveData.param.messageY;
		_msg.movePos(_msgX, _msgY, 0);
		_msg.onMenuLeave();

		_stackSelect.assignStruct(_saveData.param.stackSelect);
		(Dictionary.assignStruct incontextof _logSaveInfo)(_saveData.param.logSaveInfo);

		_face = _saveData.param.face;
		switch(_saveData.param.faceStatus){
		case FaceWindow.FW_SHOW : 		_msg.face("show"); break;
		case FaceWindow.FW_HIDE : 		_msg.face("hide"); break;
		case FaceWindow.FW_HIDEONCE : 	_msg.face("hideonce"); break;
		}

		clearMessage();

		var index = countOfLog() - 1;
		while(_logParam[index].newline){index--;}
		while(index < countOfLog()){
			_name = _logName[index];
			_mess = _logMess[index];
			_voice = _logVoice[index];
			_pan = _logParam[index].pan;
			_volume = _logParam[index].volume;
			var id = int GetElm(_logParam[index].id, 0);
			_fFont = true;
			(Dictionary.assignStruct incontextof _fontElm)(_logParam[index].font);

			var name = _name.split(",/");
			var dispName;
			var trueName;
			if(name.count == 1){
				dispName = name[0];
			}else{
				dispName = name[1];
			}
			trueName = name[0];
			outputMessage(dispName, _mess, _voice, _pan, _volume, true, ChkReadFlag(id), trueName, _logParam[index].newline);

			index++;
		}
		_advHide = false;

		show(0);

		//自動位置調整設定を反映
		_fBustupAutoPositioning = _saveData.param.autoPosition;

		//カメラ移動
		if(_saveData.param.camera_move != ""){
			moveCamera(%[pos:_saveData.param.camera, time:_saveData.param.camera_move_time]);
		}

		//アクション
		for(var i=0;i<_saveData.param.action.count;i++){
			var elm = _saveData.param.action[i];
			delete elm.target;		//必要ないので削除
			asyncAction(elm);
		}

		//エモーション
		for(var i=0;i<_saveData.param.emotion.count;i++){
			var elm = _saveData.param.emotion[i];
			emotion(elm);
		}

		//環境エフェクト
		for(var i=0;i<_saveData.param.envEffect.count;i++){
			with(_saveData.param.envEffect[i]){
				envEffect(.type, .param);
			}
		}

		//ADV画面の構築が終了したので、隠していた画面を表示する。
		EndLoad();

		_fLoad = false;

		invalidate _saveData;
		_saveData = null;

		//オートセーブ初期化
		_autoSave.init();
	}

	function quickLoad(filename){
		if(_end) return;
		if(!_hitretState) return;
		if(_fRecollect) return;
		if(IsLoadProccesing()) return;

		_tempQLoadFile = filename;

		var temp = saveMan.atQSave();
		if(temp.valid){
			if(isAuto()) auto(false);
			if(isSkip()) skip(false);

			if(CONFIG.confirmWindow[SystemRegister.CONFIRM_LOAD])
				PlaySystemVoice("Ｑロード：確認");
			CallConfirm("$c:aquamarine,midnightblue;クイックロード$c;します", SystemRegister.CONFIRM_LOAD, quickLoadRun, null);
		}
	}
	function quickLoadRun(){
		load(_tempQLoadFile);
		PlaySystemVoice("Ｑロード：実行");
		dm("クイックロードします");
	}

	function quickSave(){
		if(isSkip()) return;
		if(_fRecollect) return;
		if(_fMovie) return;
		if(!_hitretState) return;

		//一度しかクイックセーブできない（ボタン連打対策）
		if(_quickSave) return;
		_quickSave = true;

		save("qsave.bmp", -1);

		dm("クイックセーブしました");
		PlaySystemVoice("Ｑセーブ：実行");
		Information("$c:violet,indygo;クイックセーブ$c;しました");

		_msg.refreshMenu();
	}
	function autoSave(){
		if(_fPreviewMode) return;
		if(!_enableAutoSave) return;
		if(_hitretNum == 0) return;

		_autoSave.set(this, false, true, true);
		_autoSave.save("asave.bmp", -2, this);

		sysReg._autoSave = 1;
		SaveSystemRegister();

		dm("オートセーブしました");
	}

	function save(file, index=-2){
		if(_end) return;
//		if(_fRecollect) return;

		//hitret待ち状態じゃないとセーブできない
		if(!_hitretState) return;

		//一度しかクイックセーブできない（ボタン連打対策）
//		if(_quickSave) return;
//		_quickSave = true;

		//アクションタイマの一時停止
		pauseAction();

		var save = new Savedata();
		save.set(this);
		save.save(file, index, this);
		invalidate save;

		//アクションタイマの再開
		restartAction();
	}

	function close(){
		stopAction();
		_msg.interupt = true;

		//音関係停止
		StopBgm();
		StopSe();
		StopEnvSe();
		StopVoice();
		StopBgv();

		valid = false;						//シーンオブジェクト無効化
	}

	function playMovie(elm){
		//オート、スキップ強制ストップ
		_msg.auto = false;
		_msg.skip = false;

		//音関係停止
		StopBgm();
		StopSe();
		StopEnvSe();
		StopVoice();
		StopBgv();

		//ADVScreen非表示
		visible = false;

		if(_sprTrans.isTransition()){
		//まだ前のトランジッションが終了していないなら終了させる。
			transitionComplete(_sprTrans);
		}

		hide(0, true);

		PlayMovie(elm.file, this);

		_fMovie = true;
	}
	function onStopMovie(){
		StopMovie();
		visible = true;
		_fMovie = false;
	}

	function staffroll(elm){
		CallStaffRoll(elm.id, this);
	}

	function envEffect(type, elm){
		switch(type){
		case ENVEFFECT_SNOW : 
			_envEffect[ENVEFFECT_SNOW].setParam(elm);
			break;
		case ENVEFFECT_RAIN : 
			_envEffect[ENVEFFECT_RAIN].setParam(elm);
			break;
		case ENVEFFECT_BG_SCROLL : 
			_envEffect[ENVEFFECT_BG_SCROLL].setParam(elm);
			break;
		}
	}
	function isEnvEffect(type = -1){
		switch(type){
		case -1 :
			for(var i=0;i<_envEffect.count;i++){
				if(_envEffect[i].isActive()) return true;
			}
			break;
		default : 
			return _envEffect[type].isActive();
			break;
		}
	}
	function stopEnvEffect(type = -1){
		switch(type){
		case -1 :
			for(var i=0;i<_envEffect.count;i++){
				_envEffect[i].stop();
			}
			break;
		default : 
			_envEffect[type].stop();
			break;
		}
	}

	function callSystemWindow(type){
		if(!_msg.isShow()) return;
		if(_fMovie) return;
		if(_eyeCatch != null) return;
		if(IsStaffRoll()) return;

		if(isSkip()) skip(false);
		if(isAuto()) auto(false);

		if(!_startSelect && (isSkip() || isAuto())) return;

		if(!_hitretState) return;

		switch(type){
		case SYSWIN_CONFIG : 
			callConfig();
			break;
		case SYSWIN_HISTORY : 
			callHistory();
			break;
		case SYSWIN_LOAD : 
			callLoad();
			break;
		case SYSWIN_SAVE : 
			callSave();
			break;
		case SYSWIN_HIDE : 
			hide(300);
			break;
		}
	}

	function callConfig(){
		var returnMenu = _fRecollect?2:1;
		PlaySystemVoice("ゲーム：コンフィグ");
		CallConfig(this, returnMenu, 1);
	}
	function onCofigClose(){
	}

	function callHistory(){
		CallHistory(this);
	}
	function callLoad(){
		if(_fRecollect) return;

		CallLoadSave(true, this);
	}
	function callSave(){
		if(_fRecollect) return;

		CallLoadSave(false, this);
	}

	property envTone{
		getter(){return _envTone;}
		setter(v){_envTone = v;}
	}

	property hitretState{
		getter(){return _hitretState;}
	}

	property interrupt{
		setter(v){
			_scCtrl.interrupt = v;
			_msg.interrupt = v;
			if(v){
			//停止
				if(_fAction){pauseAction();}
			}else{
			//再開
				if(!_fAction){restartAction();}
			}
		}
		getter(){return _scCtrl.interrupt;}
	}

	property lastHitretID{
		getter(){return _lastHitretID;}
	}

	property HScene{
		getter(){return _fHScene;}
	}

	property previewMode{
		getter(){return _fPreviewMode;}
	}

	property visible{
		getter(){return global.Layer.visible;}
		setter(v){
			global.Layer.visible = v;
			_msg.visible = v;
		}
	}
}

ADVScreen.SYSWIN_CONFIG		= 1;
ADVScreen.SYSWIN_HISTORY	= 2;
ADVScreen.SYSWIN_LOAD		= 3;
ADVScreen.SYSWIN_SAVE		= 4;
ADVScreen.SYSWIN_HIDE		= 5;

ADVScreen.SELECTTYPE_NONE	= 0;
ADVScreen.SELECTTYPE_NORMAL	= 1;

ADVScreen.SCENETYPE_NORMAL	= 0;
ADVScreen.SCENETYPE_EVENT	= 1;

ADVScreen.ENVEFFECT_SNOW		= 0;
ADVScreen.ENVEFFECT_RAIN		= 1;
ADVScreen.ENVEFFECT_BG_SCROLL	= 2;
ADVScreen.ENVEFFECT_MAX			= 3;

ADVScreen.JUMPSTATE_NONE		= 0;
ADVScreen.JUMPSTATE_NORMAL		= 1;
ADVScreen.JUMPSTATE_SELECT_PREV	= 2;
ADVScreen.JUMPSTATE_SELECT_NEXT	= 3;
ADVScreen.JUMPSTATE_PREVIEW		= 4;

class Savedata{
	var _valid;
	var _param = %[];

	var DEFINE_PARAM = [
		//セーブされているかどうか
		["save", 0], 

		["title", GAME_TITLE], 
		["version", GAME_VERSION], 
		["save_version", SAVE_VERSION], 

		["save_date", ""], 

		//シナリオファイル名
		["scenario", ""], 
		["label", ""], 
		//シーンタイトル
		["scene", ""], 
		//hitret回数
		["hitret", 0], 
		//選択肢情報
		["select", []], 
		["stackSelect", []], 
		["selectTerminate", 0], 
		//パラメータ
		["param", []], 
		["logSaveInfo", %[]], 
		["logSelectEOF", %[]], 
		//日付
		["month", 0], 
		["day", 0], 
		["week", 0], 
		//キャラルート
		["root", 0], 

		//メッセージフレーム
		["messageFrame", 0], 
		["messageX", 0], 
		["messageY", 0], 
		//フェイス
		["face", ""], 
		["faceStatus", FaceWindow.FW_SHOW], 
		//日付表示
		["date", ""], 
		["dateShow", 0], 

		//シネマ
		["cinema", 0], 
		["cinemaColor", "black"], 
		["cinemaTrans", 255], 

		//カットイン
		["cutin", %[]], 

		//環境エフェクト
		["envEffect", []], 

		//メッセージ・日付・ループ表示のシナリオ指定消去
		["advDateHide", 0], 

		//バックログ
		["logCount", 0], 
		["logName", []], 
		["logMess", []], 
		["logVoice", []], 
		["logParam", []], 

		//ADVオブジェクト
		["advObject", []], 
		["autoPosition", true], 
		["bustupRelateFlip", false], 
		["bustupRelateCustom", ""], 
		//カメラ
		["camera", PointNumToStr(0,0,0)], 
		["camera_move", ""], 
		["camera_move_time", 0], 

		//環境トーン
		["envTone", []], 

		//フラッシュ
		["flash", ""], 

		//アクション
		["action", []], 

		//エモーション
		["emotion", []], 

		//

		//音楽
		["bgm", ""], 
		["bgmVol", 1.0], 
		["bgmSpeed", 1.0], 
		["pauseBgm", 0], 
		//環境音
		["envSe", []], 
		//環境音声
		["bgv", []], 

		["triggerCounter", -1]
	];

	function Savedata(filename=""){
		init();

		_valid = false;

		if(filename != "")
			load(filename);
	}
	function finalize(){
		invalidate _param;
	}

	function init(){
		for(var i=0;i<DEFINE_PARAM.count;i++){
			var tag = DEFINE_PARAM[i][0];
			var atrb = typeof DEFINE_PARAM[i][1];
			if(atrb == "Object"){
				if(typeof DEFINE_PARAM[i][1].count == "undefined"){
				//これはDictionary
					_param[tag] = %[];
					(Dictionary.assignStruct incontextof _param[tag])(DEFINE_PARAM[i][1]);
				}else{
				//これはArray
					_param[tag] = [];
					_param[tag].assignStruct(DEFINE_PARAM[i][1]);
				}
			}else{
				_param[tag] = DEFINE_PARAM[i][1];
			}
		}
	}

	function set(adv, fDataCopy=true, fLogCopy=true, fSaveLogCopy=true){
		with(_param){
			if(fDataCopy){
				//セーブしたことにする
				.save = 1;

				//-----------------------------------------------------------------
				//シナリオファイル名
				.scenario = adv._scenario;
				.label = adv._label;
				//シーンタイトル
				.scene = adv._scene;
				//hitret回数
				.hitret = adv._hitretNum;
				//選択肢情報
				.select.assignStruct(adv._logSelect);
				.stackSelect.assignStruct(adv._stackSelect);
				//パラメータ(シナリオ先頭でのパラメータ状態)
				.param.assign(adv._paramPrev.object());
				//キャラルート
				.root = adv._param.get(112);

				(Dictionary.assign incontextof .cutin)(adv._cutinParam);

				//メッセージフレーム
				.messageFrame = adv._msg._type;
				.messageX = adv._msgX;
				.messageY = adv._msgY;
				//フェイス
				.face = adv._face;
//				.faceStatus = adv._msg._face._status;
				//日付表示
				//.date = adv._msg._calendar._param;
				//.dateShow = adv._msg._calendar.isShow();

				//シネマ
				.cinema = adv._cinema.type;
				.cinemaColor = adv._cinema._color;
				.cinemaTrans = adv._cinema._trans;

				//絶頂カウンター
//				.triggerCounter = adv._msg._orgCounter.count;

				.envEffect.clear();
				for(var i=ADVScreen.ENVEFFECT_SNOW;i<ADVScreen.ENVEFFECT_MAX;i++){
					if(adv._envEffect[i].isActive()){
						var index = .envEffect.count;
						.envEffect[index] = %[];
						.envEffect[index].type = i;
						.envEffect[index].param = adv._envEffect[i].getParam();
					}
				}
			}

			//バックログ
			.logCount = adv._logName.count;
			if(fLogCopy){
				.logName.assign(adv._logName);
				.logMess.assign(adv._logMess);
				.logVoice.assign(adv._logVoice);
				.logParam.assign(adv._logParam);
			}

			if(fDataCopy){
				//ADVオブジェクト
				.advObject.clear();
				var index = 0;
				for(var i=0;i<adv._objList.count;i++){
					//削除予定のオブジェクトは無視
					if(adv._objList[i]._destroy != ADVOBJ_DESTROY_NONE) continue;

					.advObject[index] = %[];
					//オブジェクトタイプ
					.advObject[index].kind = adv._objList[i]._info.kind;
					.advObject[index].id = adv._objList[i]._info.id;
					.advObject[index].file = adv._objList[i]._info.file;
					.advObject[index].order = adv._objList[i]._info.order;
					.advObject[index].zOrder = adv._objList[i]._info.zOrder;
					.advObject[index].relate = adv._objList[i]._info.relate;
					.advObject[index].opacity = adv._objList[i].opacity;
					.advObject[index].rotate = adv._objList[i].rotate;
					.advObject[index].focus = adv._objList[i]._focus;
					.advObject[index].tone = adv._objList[i]._tone;
					.advObject[index].zoom = adv._objList[i]._zoomBase;
					.advObject[index].flipLR = adv._objList[i]._flipLR;
					.advObject[index].flipUD = adv._objList[i]._flipUD;
					var pos = adv._objList[i]._info.center;
					.advObject[index].center = PointNumToStr(pos.x, pos.y, pos.z);

					//トランジッション系
					if(adv._objList[i].isBlendingActivation()){
					//オブジェクトがブレンディングアクティベーション中
						.advObject[index].opacity = adv._objList[i]._endOpacity;
					}

					//アクション
					if(adv._actionList.isAction(adv._objList[i])){
					//オブジェクトがアクション中の時は、移動完了時の座標を。
						pos = adv._actionList.sequence(adv._objList[i])._world;
					}else{
					//動いてないならそのままの座標を。
						pos = adv._objList[i]._worldPos;
					}

					.advObject[index].trimming = adv._objList[i].info.trimming;

					.advObject[index].worldPos = PointNumToStr(pos.x, pos.y, pos.z);
					pos = adv._objList[i]._basePos;
					.advObject[index].baseBase = PointNumToStr(pos.x, pos.y, pos.z);

					index++;
				}
				.autoPosition = adv._fBustupAutoPositioning;
				.bustupRelateFlip = adv._fBustupRelateFlip;
				.bustupRelateCustom = adv._bustupRelateCustom;

				//カメラ位置(補正しておく)
				var pos = new Point();
				var scale;
				if(adv._fAction && adv._fCamera_move){
					pos.set(adv._camera_move._end.x, adv._camera_move._end.y, adv._camera_move._end.z);
					//scale = 2.0 * (1.0 + ((pos.z+BG_RANGE_MAX)) / BG_RANGE_MAX);
					scale = 2.0;
					pos.x /= scale;
					pos.y /= scale;
					pos.z += BG_RANGE_MAX;
					.camera = PointNumToStr(pos.x, pos.y, pos.z);

					pos.set(adv._camera_move._start.x, adv._camera_move._start.y, adv._camera_move._start.z);
					scale = 2.0 * (1.0 + ((pos.z+BG_RANGE_MAX)) / BG_RANGE_MAX);
					pos.x /= scale;
					pos.y /= scale;
					pos.z += BG_RANGE_MAX;
					.camera_move = PointNumToStr(pos.x, pos.y, pos.z);

					.camera_move_time = adv._camera_move_time_base;
				}else{
					pos.set(adv._camera_pos);
					//scale = 2.0 * (1.0 + ((pos.z+BG_RANGE_MAX)) / BG_RANGE_MAX);
					scale = 2.0;
					pos.x /= scale;
					pos.y /= scale;
					pos.z += BG_RANGE_MAX;
					.camera = PointNumToStr(pos.x, pos.y, pos.z);
				}

				//環境トーン
				.envTone.assignStruct(adv.envTone);

				//アクション
				.action.clear();
				var index = 0;
				for(var i=0;i<adv._actionList.count;i++){
					.action[index] = %[];
					if(adv._actionList._list[i]._world != void){
					//_worldが有効ならADVObj
						if(isvalid adv._actionList._list[i]._target){
							if(adv._actionList._list[i]._target.destroy == ADVOBJ_DESTROY_NONE){
								(Dictionary.assign incontextof .action[index++])(adv._actionList._list[i]._elm);
							}
						}
					}else{
						(Dictionary.assign incontextof .action[index++])(adv._actionList._list[i]._elm);
					}
				}

				//エモーション
				for(var i=0;i<adv._objList.count;i++){
					var obj = adv._objList[i];

					//削除予定のオブジェクトは無視
					if(obj._destroy != ADVOBJ_DESTROY_NONE) continue;

					var list = obj.getEmotionList();

					for(var li=0;li<list.count;li++){
						var em = list.at(li);
						if(em.attribute == AnimationSequence.atbVolatile) continue;

						var ei = .emotion.count;
						.emotion[ei] = %[];
						(Dictionary.assignStruct incontextof .emotion[ei])(em.param);
					}
				}

				//音楽
				if(BGM.isPlay("", false)){
					var obj = BGM.objectOfId("BGM_1", false);
					if(obj != -1){
						.bgm = obj._file;
						.pauseBgm = obj.paused;
						.bgmSpeed = obj.speed;
						.bgmVol = int(obj.playVolume * 100);
					}
					obj = BGM.objectOfId("BGM_2", false);
					if(obj != -1){
						.bgm = obj._file;
						.pauseBgm = obj.paused;
						.bgmSpeed = obj.speed;
						.bgmVol = int(obj.playVolume * 100);
					}
				}
				//環境音
				.envSe.assign(ENVSE.idList(false));
				//環境音声
				.bgv.assign(BGV.idList(false));
			}

			if(fSaveLogCopy){
				(Dictionary.assignStruct incontextof .logSaveInfo)(adv._logSaveInfo);
				(Dictionary.assignStruct incontextof .logSelectEOF)(adv._logSelectEOF);
			}
		}
	}

	function diff(src){
		var diffDic = %[];

		for(var i=0;i<DEFINE_PARAM.count;i++){
			if(DEFINE_PARAM[i][2] !== void) continue;
			if(DEFINE_PARAM[i][2] == 0) continue;

			if(_param[DEFINE_PARAM[0][0]] != src._param[DEFINE_PARAM[0][0]])
				diffDic[DEFINE_PARAM[0][0]] = _param[DEFINE_PARAM[0][0]];
		}

		return diffDic;
	}

	function isExist(filename){
		if(Storages.isExistentStorage(DATA_PATH + filename)){
		//セーブフォルダ内チェック
			return true;
		}else if(Storages.isExistentStorage(filename)){
		//filenameをフルパスとしてチェック
			return true;
		}else{
			return false;
		}
	}

	function load(filename){
		var now = System.getTickCount();

		_valid = false;

		var path;
		if(Storages.isExistentStorage(DATA_PATH + filename)){
		//セーブフォルダ内チェック
			path = DATA_PATH;
		}else if(Storages.isExistentStorage(filename)){
		//filenameをフルパスとしてチェック
			path = "";
		}else{
			dm("セーブデータが見つかりません : " + filename);
			return false;
		}

		var img = new Layer(win, win.baseLayer);
		try{
			img.loadImages(path + filename);
		}catch{
			dm("001.セーブデータが不正です : " + filename);
			invalidate img;
			return false;
		}

		var temp;
		try{
			temp = Scripts.evalStorage(path + filename, "o%d".sprintf(GetImageFileSize(img)));
		}catch{
			dm("002.セーブデータが不正です : " + filename);
			invalidate img;
			return false;
		}
		invalidate img;

		var succes = true;
		//セーブデータであるかチェック
		if(typeof temp[0] != "Object"){
		//Objectタイプがどうかチェック
			succes = false;
		}else if(temp[0].title !== void && temp[0].version !== void){
		//読み込んだデータにtitle,versionタグがあるかチェック
			if(temp[0].title != GAME_TITLE){
			//タイトル名をチェック
				succes = false;
				dm("003.セーブデータが不正です : " + filename);
			}
			if(real(temp[0].save_version) != real(SAVE_VERSION)){
			//バージョンをチェック
				succes = false;
				dm("004.セーブデータが不正です : " + filename);
			}
		}else{
			succes = false;
			dm("004.セーブデータが不正です : " + filename);
		}

		if(succes == false){
			return false;
		}

		if(temp[0].save == 0){
		//セーブされていないデータだけど、中身は正常
			_valid = false;		//セーブされていないファイルは無効扱い
			return true;
		}

		_valid = true;

		//読み込んだデータをコピー
		(Dictionary.assign incontextof _param)(temp[0]);

		//内容チェック
		for(var i=0;i<DEFINE_PARAM.count;i++){
			//定義タグが存在しない場合はデフォルト値を設定する
			if(_param[DEFINE_PARAM[i][0]] === void){
				_param[DEFINE_PARAM[i][0]] = DEFINE_PARAM[i][1];
			}
		}

		@if(__DEBUGMODE__)
			dm("ロード処理に"+(System.getTickCount() - now) + "msかかりました");
		@endif

		return true;
	}

	function save(filename, index=-1, adv=null, init=false){
	//index >=  0 : 通常セーブ
	//index == -1 : クイックセーブ
	//index == -2 : その他（管理なし）
		if(index == -1){
			var no = saveMan.qsaveIndex() + 1;
			if(no >= QSAVEDATA_MAX) no = 0;
			filename = "qsave%02d.bmp".sprintf(no + 1);
		}

		var now = System.getTickCount();

		var temp = [];
		temp[0] = _param;

		//if(adv != null) set(adv);

		@if(__DEBUGMODE__)
			var fDebugVisible = debug.visible;
			debug.visible = false;
		@endif

		//現在の時間を設定
		var date = new Date();
		_param.save_date = "%04d/%02d/%02d_%02d:%02d:%02d".sprintf(date.getYear(), date.getMonth()+1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
		invalidate date;

		//ゲーム日時
		var gameDate = _param.date;
		var array = gameDate.split(",/");
		if(array.count == 3){
			if(int(array[0]) == 0 && int(array[1]) == 0){
				gameDate = "";
			}else{
				gameDate = int(array[0]);
				gameDate += "月";
				gameDate += int(array[1]);
				gameDate += "日 ";
				gameDate += array[2];
			}
		}

		//サムネールセーブ
		//=============================================================
		var sprThumb = new global.Layer(win, win.baseLayer);
		if(adv != null && index != -2){
			var obj = adv.getADVObjectObject("背景");
			var head = obj.info.file.substring(0, 4);
			if(head.length == 0) head = "black";
			if(CG_HSCENE_LIST[head] === void){
			//通常背景か通常イベント
				var spr = new global.Layer(win, win.baseLayer);
				adv.screenShot(spr, true);

				var thumbW = 120;
				var thumbH = 90;
				sprThumb.setSize(thumbW, thumbH);
				sprThumb.stretchCopy(0, 0, sprThumb.width, sprThumb.height, spr, 0, 0, spr.width, spr.height, stCubic);
				invalidate spr;
			}else{
			//Ｈシーン
				var spr = new global.Layer(win, win.baseLayer);
				adv.screenShot(spr, true);

				var thumbW = 120;
				var thumbH = 90;
				sprThumb.setSize(thumbW, thumbH);
				sprThumb.stretchCopy(0, 0, sprThumb.width, sprThumb.height, spr, 0, 0, spr.width, spr.height, stCubic);
				sprThumb.doBoxBlur(4, 4);
				invalidate spr;

				sprThumb.setSizeToImageSize();

				var tone = TONE_DIC[obj._tone];
				if(tone !== void){
					if(tone[3]) sprThumb.doGrayScale();
					sprThumb.adjustGamma(
						tone[0][0], tone[0][1], tone[0][2],
						tone[1][0], tone[1][1], tone[1][2],
						tone[2][0], tone[2][1], tone[2][2]
					);
				}
			}
			sprThumb.saveLayerImage(DATA_PATH + filename);
		}else{
			sprThumb.loadImages("FRM_0351@");
			sprThumb.setSizeToImageSize();
			sprThumb.saveLayerImage(DATA_PATH + filename);
		}

		//データセーブ
		//=============================================================
		@if(__FILE_CRYPT__ == 0)
			temp.saveStruct(DATA_PATH + filename, "o%d".sprintf(GetImageFileSize(sprThumb)));
		@endif
		@if(__FILE_CRYPT__ == 1)
			temp.saveStruct(DATA_PATH + filename, "zo%d".sprintf(GetImageFileSize(sprThumb)));
		@endif

		invalidate sprThumb;

		//管理ファイルにもヘッダ情報を保存
		//=============================================================
		//セーブ情報作成
			var name = "";
			var mess = "";
			if(adv != null){
				var logIndex = adv._logName.count-1;
				name = adv._logName[logIndex];
				if(name.indexOf("/") != -1) name = name.split("/")[1];
				if(name == "心の声" || name == "語り" || name == "モノローグ")
					name = "";

				mess = adv._logMess[logIndex];
				//強制改行文字・全角スペースを消す
				var reg1 = new RegExp("／|　", "g");
				mess = mess.replace(reg1, "");
				invalidate reg1;
				//制御コードを消す
				var ma = new MessageArea(adv.window, adv);
				name = ma.extractOutputString(name);
				mess = "「" + ma.extractOutputString(mess) + "」";
				invalidate ma;
			}
		//=============================================================
		var comment = "";
		if(adv) comment = adv._scene;

		if(index >= 0){
		//通常セーブ
			if(!init){
				saveMan.set(index, filename, gameDate, _param.save_date, name+mess, _param.root);
			}else{
				saveMan.reset(index);
			}
		}else if(index == -1){
		//QSave
			if(!init){
				saveMan.setQSave(filename, gameDate, _param.save_date, name+mess, _param.root);
			}else{
				saveMan.resetQSave();
			}
		}else if(index == -2){
		//ASave
			if(!init){
				saveMan.setASave(filename, gameDate, _param.save_date, name+mess, _param.root);
			}else{
				saveMan.resetASave();
			}
		}
		saveMan.save();

		@if(__DEBUGMODE__)
			debug.visible = fDebugVisible;
			dm("セーブ処理に"+(System.getTickCount() - now) + "msかかりました");
		@endif
	}

	function applyToAdv(adv, fApplyLog=true, fApplySaveInfo=true){
//		if(!isValid()) return;

		with(_param){
			adv._scenario = .scenario;
			adv._scene = .scene;
			//hitret回数
			adv._hitretNum = .hitret;
			//選択肢情報
			adv._logSelect.assign(.select);
			//パラメータ(シナリオ先頭でのパラメータ状態)
			adv._param.object().assignStruct(.param);

			//バックログ
			if(fApplyLog){
				adv._logName.assign(.logName);
				adv._logMess.assign(.logMess);
				adv._logVoice.assign(.logVoice);
				adv._logParam.assign(.logParam);
			}

			if(fApplySaveInfo){
				(Dictionary.assignStruct incontextof adv._logSaveInfo)(.logSaveInfo);
				(Dictionary.assignStruct incontextof adv._logSelectEOF)(.logSelectEOF);
			}
		}
	}

	//有効なセーブデータか
	function isValid(){
		return _valid;
	}

	property param{
		setter(v){_param = v;}
		getter(){return _param;}
	}
}

class LoadProcessScreen extends Sprite{
	var _spr = [];

	function LoadProcessScreen(win, par){
		super.Sprite(...);

		//ベース
		loadImages("FRM_0501@");
		setSizeToImageSize();

/*
		//ロゴ
		_spr[0] = new global.Sprite(win, this);
		_spr[0].loadImages("FRM_0514");
		_spr[0].setSizeToImageSize();
		_spr[0].setPos(WINDOW_CENTER_X-_spr[0].width\2, WINDOW_CENTER_Y-_spr[0].height\2);
		_spr[0].visible = true;
*/

		visible = true;
	}
	function finalize(){
		InvalidateArray(_spr);
		invalidate _spr;

		super.finalize();
	}
}

//ロード処理のために画面を隠す
var SPR_ADV_HIDE = null;
function BeginLoad(func=null){
	if(SPR_ADV_HIDE != null){
		if(!SPR_ADV_HIDE.isActivation() && func != null){
			func();
		}else if(func != null){
			SPR_ADV_HIDE.setTransitionCompleteCall(func);
		}else{
			EndLoad();
		}
		return;
	}

	SPR_ADV_HIDE = new LoadProcessScreen(win, win.baseLayer);
	with(SPR_ADV_HIDE){
		.setTransitionCompleteCall(func, true);

		.opacity = 0;
		.setBlendingEnvelope(255);
		.beginActivation(300);
		.absolute = LAYER_COVER;
		.visible = true;
	}
}
function EndLoad(func=null){
	if(SPR_ADV_HIDE === null) return;
	with(SPR_ADV_HIDE){
		//トランジッションが終わったら削除する
		.setTransitionCompleteCall(DestroyLoad, true);

		.setBlendingEnvelope(0);
		.beginActivation(500);
	}
}
function DestroyLoad(){
	if(SPR_ADV_HIDE === null) return;

	invalidate SPR_ADV_HIDE;
	SPR_ADV_HIDE = null;
}
function IsLoadProccesing(){
	return (SPR_ADV_HIDE != null);
}

class CinemaStrap extends Layer{
	var _type = 0;
	var _color = "black";
	var _trans = 255;
	var _strap = [];

	var _indexHide = 0;

	var STRAP_WIDTH = 1280;
	var STRAP_HEIGHT = 128;

	var STRAP_POS = [
		[0, 0], 
		[0, WINDOW_HEIGHT-STRAP_HEIGHT]
	];

	function CinemaStrap(win, par){
		super.Layer(...);
		hasImage = false;
		setSize(WINDOW_WIDTH, WINDOW_HEIGHT);

		for(var i=0;i<4;i++){
			_strap[i] = new Sprite(win, par);
			with(_strap[i]){
				.opacity = 0;
				.hitThreshold = 256;
				.setTransitionCompleteCall(onTransitionComplete);
			}
		}
		//奥
		_strap[0].absolute = ADVLAYER_CINEMA1;
		_strap[1].absolute = ADVLAYER_CINEMA1;
		//手前
		_strap[2].absolute = ADVLAYER_CINEMA2;
		_strap[3].absolute = ADVLAYER_CINEMA2;

		_strap[0].setPos(0, 0);
		_strap[1].setPos(0, WINDOW_HEIGHT-STRAP_HEIGHT);
		_strap[2].setPos(0, 0);
		_strap[3].setPos(0, WINDOW_HEIGHT-STRAP_HEIGHT);
	}
	function finalize(){
		InvalidateArray(_strap);
	}

	function set(type=0, fade=500, color="black", trans=255){
		if(_type == type) return;

		_color = color;
		_trans = trans;
		var c = GetDefineColorA(color, trans);

		for(var i=0;i<_strap.count;i++){
			if(_strap[i].isActivation()) _strap[i].flushActivation();
		}

		var index;
		if(type == 0){
			switch(_type){
			case 1 : index = 0; break;
			case 2 : index = 2; break;
			}
			_strap[index].setMovingEnvelope(_strap[index].left, _strap[index].top, _strap[index].left, -STRAP_HEIGHT, 2);
			_strap[index+1].setMovingEnvelope(_strap[index+1].left, _strap[index+1].top, _strap[index+1].left, _strap[index+1].top+STRAP_HEIGHT, 2);
			for(var i=index;i<index+2;i++){
				_strap[i].setBlendingEnvelope(0);
				_strap[i].beginActivation(fade);
			}
			_indexHide = index;
		}else if(_type == 0 && type != 0){
			switch(type){
			case 1 : index = 0; _indexHide = 2; break;
			case 2 : index = 2; _indexHide = 0; break;
			}
			_strap[index].setMovingEnvelope(STRAP_POS[0][0], -STRAP_HEIGHT, STRAP_POS[0][0], STRAP_POS[0][1], 2);
			_strap[index+1].setMovingEnvelope(STRAP_POS[1][0], STRAP_POS[1][1]+STRAP_HEIGHT, STRAP_POS[1][0], STRAP_POS[1][1], 2);
			for(var i=index;i<index+2;i++){
				with(_strap[i]){
					.setSize(STRAP_WIDTH, STRAP_HEIGHT);
					.fillRect(0, 0, .width, .height, c);
					.opacity = 0;
					.setBlendingEnvelope(255);
					.beginActivation(fade);
					.visible = true;
				}
			}
		}else if(_type == 1 && type == 2){
			_indexHide = 0;

			index = 0;
			for(var i=index;i<index+2;i++){
				with(_strap[i]){
					.setBlendingEnvelope(0);
					.beginActivation(fade);
				}
			}
			index = 2;
			_strap[index].setPos(STRAP_POS[0][0], STRAP_POS[0][1], STRAP_POS[0][0], STRAP_POS[0][1]);
			_strap[index+1].setPos(STRAP_POS[1][0], STRAP_POS[1][1], STRAP_POS[1][0], STRAP_POS[1][1]);
			for(var i=index;i<index+2;i++){
				with(_strap[i]){
					.setSize(STRAP_WIDTH, STRAP_HEIGHT);
					.fillRect(0, 0, .width, .height, c);
					.opacity = 0;
					.setBlendingEnvelope(255);
					.beginActivation(fade);
					.visible = true;
				}
			}
		}else if(_type == 2 && type == 1){
			index = 0;
			_strap[index].setPos(STRAP_POS[0][0], STRAP_POS[0][1], STRAP_POS[0][0], STRAP_POS[0][1]);
			_strap[index+1].setPos(STRAP_POS[1][0], STRAP_POS[1][1], STRAP_POS[1][0], STRAP_POS[1][1]);
			for(var i=index;i<index+2;i++){
				with(_strap[i]){
					.setSize(STRAP_WIDTH, STRAP_HEIGHT);
					.fillRect(0, 0, .width, .height, c);
					.opacity = 255;
					.visible = true;
				}
			}

			index = 2;
			for(var i=index;i<index+2;i++){
				with(_strap[i]){
					.setBlendingEnvelope(0);
					.beginActivation(fade);
				}
			}
			_indexHide = 2;
		}

		visible = true;

		_type = type;
	}
	function onTransitionComplete(){
		for(var i=0;i<_strap.count;i++){
			if(_strap[i].opacity) return;
		}
		visible = false;
	}

	function reset(){
		for(var i=0;i<_strap.count;i++){
			with(_strap[i]){
				.setSize(32, 32);
				.opacity = 0;
				.visible = false;
			}
		}
		_type = 0;
	}

	property type{
		getter(){return _type;}
	}
}

//-----------------------------------------------
//スクリプトの評価式で利用するコマンドラッパー
//-----------------------------------------------
var ADVOBJ_TEMP = null;	//一時的なADVScreen対象
function GetAdvScene(){
	if(ADVOBJ_TEMP != null)	return ADVOBJ_TEMP;
	else					return game.getScene(SCENE_ADV);
}
function SetAdvSceneTemp(target=null){
	ADVOBJ_TEMP = target;
}
function GetParam(id){
	var scene = GetAdvScene();
	return scene.getParam(id);
}
function SetParam(id, arg){
	var scene = GetAdvScene();
	return scene.setParam(id, arg);
}
function BiggerParamIndex(arg*){
//引数リスト内で一番値の大きいパラメータのインデックスを返す。
//複数存在する場合は若いインデックスを優先
	if(arg.count == 0) return -1;
	var param = [];
	for(var i=0;i<arg.count;i++) param[i] = GetParam(arg[i]);

	var index = 0;
	var max = param[0];
	for(var i=1;i<param.count;i++){
		if(max < param[i]){
			max = param[i];
			index = i;
		}
	}

	return index;
}
function SmallerParamIndex(arg*){
//引数リスト内で一番値の小さいパラメータのインデックスを返す。
//複数存在する場合は若いインデックスを優先
	if(arg.count == 0) return -1;

	var param = [];
	for(var i=0;i<arg.count;i++) param[i] = GetParam(arg[i]);

	var index = 0;
	var min = param[0];
	for(var i=1;i<param.count;i++){
		if(min > param[i]){
			min = param[i];
			index = i;
		}
	}

	return index;
}
function ChkFlagOn(id){
	var scene = GetAdvScene();
	return scene.chkFlagOn(id);
}
function ChkFlagOff(id){
	var scene = GetAdvScene();
	return scene.chkFlagOff(id);
}
function CountFlagOn(args*){
	var scene = GetAdvScene();
	var count = 0;
	for(var i=0;i<args.count;i++){
		if(scene.chkFlagOn(args[i])) count++;
	}
	return count;
}
function CountFlagOff(args*){
	var scene = GetAdvScene();
	var count = 0;
	for(var i=0;i<args.count;i++){
		if(scene.chkFlagOn(args[i]) == 0) count++;
	}
	return count;
}
function ChkSelect(id){
	var scene = GetAdvScene();
	if(typeof id == "Integer")
		return scene.chkSelect(id);
	else
		return scene.chkSelectStr(id);
}
function ChkDate(month, day){
	var scene = GetAdvScene();
	return scene.chkDate(month, day);
}
function IsRecollect(id=-1){
	var scene = GetAdvScene();
	if(scene === void)
		return false;
	else
		return scene.isRecollect(id);
}

