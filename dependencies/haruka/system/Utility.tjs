// Utils.tjs - ユーティリティ関数
// Copyright (C)2001-2008, W.Dee and contributors  改変・配布は自由です

//追加関数
//一度に複数の要素をaddする
Array.adds = function (args*){
	for(var i=0;i<args.count;i++){
		add(args[i]);
	}
};

//色見本
var DEFINE_COLOR = %[
	black				: 0x000000, 
	dimgray				: 0x696969, 
	gray				: 0x808080, 
	dkgray				: 0xa9a9a9, 
	silver				: 0xc0c0c0, 
	ltgray				: 0xd3d3d3, 
	gainsboro			: 0xdcdcdc, 
	whitesmoke			: 0xf5f5f5, 
	white				: 0xffffff, 
	maroon				: 0x800000, 
	dkred				: 0x8b0000, 
	red					: 0xff0000, 
	orangered			: 0xff4500, 
	dkorange			: 0xff8c00, 
	orange				: 0xffa500, 
	gold				: 0xffd700, 
	olive				: 0x808000, 
	yellow				: 0xffff00, 
	dkgoldenrod			: 0xb8860b, 
	saddlebrown			: 0x8b4513, 
	chocolate			: 0xd2691e, 
	goldenrod			: 0xdaa520, 
	firebrick			: 0xb22222, 
	brown				: 0xa52a2a, 
	sienna				: 0xa0522d, 
	peru				: 0xcd853f, 
	tomato				: 0xff6347, 
	coral				: 0xff7f50, 
	indianred			: 0xcd5c5c, 
	sandybrown			: 0xf4a460, 
	dkkhaki				: 0xbdb76b, 
	salmon				: 0xfa8072, 
	dksalmon			: 0xe9967a, 
	ltsalmon			: 0xffa07a, 
	ltcoral				: 0xf08080, 
	burlywood			: 0xdeb887, 
	tan					: 0xd2b48c, 
	khaki				: 0xf0e68c, 
	rosybrown			: 0xbc8f8f, 
	palegoldenrod		: 0xeee8aa, 
	navajowhite			: 0xffdead, 
	wheat				: 0xf5deb3, 
	moccasin			: 0xffe4b5, 
	peachpuff			: 0xffdab9, 
	bisque				: 0xffe4c4, 
	blanchedalmond		: 0xffebcd, 
	lemonchiffon		: 0xfffacd, 
	ltgoldenrodyellow	: 0xfafad2, 
	papayawhip			: 0xffefd5, 
	antiquewhite		: 0xfaebd7, 
	beige				: 0xf5f5dc, 
	cornsilk			: 0xfff8dc, 
	ltyellow			: 0xffffe0, 
	mistyrose			: 0xffe4e1, 
	linen				: 0xfaf0e6, 
	oldlace				: 0xfdf5e6, 
	seashell			: 0xfff5ee, 
	floralwhite			: 0xfffaf0, 
	ivory				: 0xfffff0, 
	snow				: 0xfffafa, 
	chartreuse			: 0x7fff00, 
	lawngreen			: 0x7cfc00, 
	dkgreen				: 0x006400, 
	green				: 0x008000, 
	lime				: 0x00ff00, 
	forestgreen			: 0x228b22, 
	olivedrab			: 0x6b8e23, 
	dkolivegreen		: 0x556b2f, 
	greenyellow			: 0xadff2f, 
	yellowgreen			: 0x9acd32, 
	limegreen			: 0x32cd32, 
	dkseagreen			: 0x8fbc8f, 
	ltgreen				: 0x90ee90, 
	palegreen			: 0x98fb98, 
	honeydew			: 0xf0fff0, 
	springgreen			: 0x00ff7f, 
	mediumspringgreen	: 0x00fa9a, 
	ltseagreen			: 0x20b2aa, 
	seagreen			: 0x2e8b57, 
	mediumseagreen		: 0x3cb371, 
	turquoise			: 0x40e0d0, 
	mediumturquoise		: 0x48d1cc, 
	mediumaquamarine	: 0x66cdaa, 
	aquamarine			: 0x7fffd4, 
	mintcream			: 0xf5fffa, 
	teal				: 0x008080, 
	dkcyan				: 0x008b8b, 
	cyan				: 0x00ffff, 
	aqua				: 0x00ffff, 
	dkturquoise			: 0x00ced1, 
	deepskyblue			: 0x00bfff, 
	navy				: 0x000080, 
	dkblue				: 0x00008b, 
	mediumblue			: 0x0000cd, 
	blue				: 0x0000ff, 
	midnightblue		: 0x191970, 
	dodgerblue			: 0x1e90ff, 
	dkslategray			: 0x2f4f4f, 
	royalblue			: 0x4169e1, 
	steelblue			: 0x4682b4, 
	cadetblue			: 0x5f9ead, 
	cornflowerblue		: 0x6495ed, 
	slategray			: 0x708090, 
	ltslategray			: 0x778899, 
	skyblue				: 0x87ceeb, 
	ltskyblue			: 0x87cefa, 
	ltblue				: 0xadd8e6, 
	paleturquoise		: 0xafeeee, 
	ltsteelblue			: 0xb0c4de, 
	powderblue			: 0xb0e0e6, 
	ltcyan				: 0xe0ffff, 
	lavender			: 0xe6e6fa, 
	azure				: 0xf0ffff, 
	aliceblue			: 0xf0f8ff, 
	ghostwhite			: 0xf8f8ff, 
	indygo				: 0x4b0082, 
	dkviolet			: 0x9400d3, 
	blueviolet			: 0x8a2be2, 
	dkorchid			: 0x9932cc, 
	dkslateblue			: 0x483d8b, 
	mediumorchid		: 0xba55d3, 
	slateblue			: 0x6a5acd, 
	mediumslateblue		: 0x7b68ee, 
	mediumpurple		: 0x9370db, 
	purple				: 0x800080, 
	dkmagenta			: 0x8b008b, 
	magenta				: 0xff00ff, 
	fuchsia				: 0xff00ff, 
	deeppink			: 0xff1493, 
	crimson				: 0xdc143c, 
	mediumvioletred		: 0xc71585, 
	hotpink				: 0xff69b4, 
	orchid				: 0xda70d6, 
	palevioletred		: 0xdb7093, 
	violet				: 0xee82ee, 
	plum				: 0xdda0dd, 
	ltpink				: 0xffb6c1, 
	thistle				: 0xd8bfd8, 
	pink				: 0xffc0cb, 
	lavenderblush		: 0xfff0f5, 
	dummy				: 0
];

//色調定数辞書配列
//[[rgamma, rfloor, rceil], [rgamma, rfloor, rceil], [rgamma, rfloor, rceil], mono_prev, mono_post]
var TONE_DIC = %[
	/* 昼   */ daytime      : [[1.0, 0, 255], [1.0, 0, 255], [1.0, 0, 255], 0, 0], 
	/* 昼雨 */ daytime_rain : [[1.0, 0, 210], [1.0, 0, 210], [1.0, 0, 220], 0, 0], 
	/* 夕   */ evening      : [[1.2, 0, 255], [0.8, 0, 255], [0.8, 0, 255], 0, 0], 
	/* 夕雨 */ evening_rain : [[1.0, 0, 255], [1.0, 0, 255], [1.0, 0, 255], 0, 0], 
	/* 夜   */ night        : [[0.9, 0, 180], [0.9, 0, 180], [1.2, 0, 230], 0, 0], 
	/* 夜   */ night_l      : [[0.9, 0, 220], [0.9, 0, 220], [1.0, 0, 250], 0, 0], 
	/* 深夜 */ midnight     : [[1.0, 0, 150], [1.0, 0, 150], [1.0, 0, 180], 0, 0], 

     negative:[[1.0, 255,   0],[1.0, 255,   0],[1.0, 255,   0], 0, 0],
   monochrome:[[1.0,   0, 255],[1.0,   0, 255],[1.0,   0, 255], 1, 0],
mono_negative:[[1.0, 255,   0],[1.0, 255,   0],[1.0, 255,   0], 1, 0],
        sepia:[[1.3,   0, 255],[1.0,   0, 255],[0.8,   0, 255], 1, 0],
    sepia_col:[[1.3,   0, 255],[1.0,   0, 255],[0.8,   0, 255], 0, 0],
      dksepia:[[0.8,   0, 255],[0.6,   0, 255],[0.5,   0, 255], 1, 0],
  dksepia_col:[[0.8,   0, 255],[0.6,   0, 255],[0.5,   0, 255], 0, 0],
      ltsepia:[[1.8,   0, 255],[1.4,   0, 255],[1.1,   0, 255], 1, 0],
  ltsepia_col:[[1.8,   0, 255],[1.4,   0, 255],[1.1,   0, 255], 0, 0],
       normal:[[1.0,   0, 255],[1.0,   0, 255],[1.0,   0, 255], 0, 0]
];
function AdjustGamma(layer, elm){
	if(IsGammaNormal(elm)) return;

	if(elm[3]) layer.doGrayScale();

	layer.adjustGamma(
		elm[0][0], elm[0][1], elm[0][2], 
		elm[1][0], elm[1][1], elm[1][2], 
		elm[2][0], elm[2][1], elm[2][2]
	);

	if(elm[4]) layer.doGrayScale();
}
function IsGammaNormal(elm){
	return (
		elm[0][0] == 1.0 && elm[0][1] == 0 && elm[0][2] == 255 &&
		elm[1][0] == 1.0 && elm[1][1] == 0 && elm[1][2] == 255 &&
		elm[2][0] == 1.0 && elm[2][1] == 0 && elm[2][2] == 255 &&
		elm[3] == 0 && elm[4] == 0
	);
}
function IsGammaEqual(elm1, elm2){
	return (
		elm1[0][0] == elm2[0][0] && elm1[0][1] == elm2[0][1] && elm1[0][2] == elm2[0][2] &&
		elm1[1][0] == elm2[1][0] && elm1[1][1] == elm2[1][1] && elm1[1][2] == elm2[1][2] &&
		elm1[2][0] == elm2[2][0] && elm1[2][1] == elm2[2][1] && elm1[2][2] == elm2[2][2] &&
		elm1[3] == elm2[3] && elm1[4] == elm2[4]
	);
}

//色変換
function RGB(r, g, b){
	return ((r<<16) | (g<<8) | b);
}
function RGBA(r, g, b, a=0xFF){
	return ((a<<24) | (r<<16) | (g<<8) | b);
}
function GetDefineColor(col){
	var ret = -1;
	col = col.toLowerCase();

	var rgb = col.split(",/");
	if(rgb.count >= 3){
	//RGB
		ret = RGB(int(rgb[0]), int(rgb[1]), int(rgb[2]));
	}else{
	//Color Chart
		if(DEFINE_COLOR[col] !== void)
			ret = DEFINE_COLOR[col];
	}

	return ret;
}
function GetDefineColorA(col, a=0xff){
	var ret = GetDefineColor(col);
	if(ret == -1)	return ret;
	else			return ret ^ (a << 24);
}

// 0 - max までの乱数を発生させる。
var RANDOM = new Math.RandomGenerator();
function randomSeed(seed){
	return RANDOM.randomize(seed);
}
function random(max){
	return RANDOM.random32() % (int(max)+1);
}
function random2(min, max){
	return min + random(max - min);
}

function FillRect(spr, color){
	color = color.toUpperCase();

	var w = spr.width;
	var h = spr.height;
	var col = GetDefineColorA(color);
	if(col != -1)	spr.fillRect(0, 0, w, h, col);
	else			spr.fillRect(0, 0, w, h, 0);
}

//整数文字列を数値に変換
function str2num(str)
{
	var flag = 1;
	var res = 0;
	for(var i=0;i<str.length;i++){
		res *= 10;
		var ch = str[i];
		switch(ch){
		case "１" : res += 1; break;
		case "２" : res += 2; break;
		case "３" : res += 3; break;
		case "４" : res += 4; break;
		case "５" : res += 5; break;
		case "６" : res += 6; break;
		case "７" : res += 7; break;
		case "８" : res += 8; break;
		case "９" : res += 9; break;
		case "-" : case "−" : flag *= -1; break;
		default : res += ch - "0"; break;
		}
	}
	return res * flag;
}


function han2zen(str)
{
	// 半角→全角 ( 英数のみ )
	var res;
	for(var i=0;i<str.length;i++)
	{
		var num=#str[i];
		if(num>=0x0020 && num<=0x7e)
			res+=$(0xff00+num-0x20); // UNICODE
		else res+=str[i];
	}
	return res;
}


function kansuuji(
	n,
	digits = "〇一二三四五六七八九",
	small_units = "　十百千",
	large_units = "　万億兆京",
	zero_expression = "ゼロ",
	minus_expression = "マイナス"
	)
{
	// n を一般的な漢数字表記にして返す
	// TJS の整数型は 922京ほどまでなので京より上の桁の処理は必要ない

	n = int n;
	if(n == 0) return zero_expression;
	var out = ""; // 出力文字列
	if(n < 0) n = -n, out = minus_expression;
	n = string n; // 文字列に変換

	var n_len = n.length;
	var n_pos = n_len - 1;
	var nonzero = false;

	for(var i = 0; i < n_len; i ++, n_pos --)
	{
		var small_unit = n_pos & 3;
		var digit = +n[i];
		switch(small_unit)
		{
		case 0: // 1 の桁
			if(digit != 0) out += digits[digit], nonzero = true;
			if(nonzero && n_pos) out += large_units[n_pos >> 2];
			nonzero = false;
			break;
		case 1: // 十の桁
		case 2: // 百の桁
		case 3: // 千の桁
			if(digit != 0)
			{
				/* 千の桁は 万以上の場合慣用的に 一千という。
				   また、一百や一十とはいわない。 */
				if(digit != 1 || (small_unit == 3 && n_pos > 4))
					out += digits[digit] + small_units[small_unit];
				else
					out += small_units[small_unit];
				nonzero = true;
			}
			break;
		}
	}

	return out;
}

function kansuuji_simple(
	n,
	digits = "〇一二三四五六七八九",
	point = "・",
	minus = "マイナス")
{
	// n を漢数字表記にするが、桁単位はつけない

	n = string n;
	var n_len = n.length;
	var out = "";
	for(var i = 0; i < n_len; i++)
	{
		var digit = n[i];
		if(digit == ".")
			out += point;
		else if(digit == "-")
			out += minus;
		else if(digit >= '0' && digit <= '9')
			out += digits[+digit];
		else
			out += digit;
	}
	return out;
}

function number_format(n)
{
	// n を３桁ごとに カンマで区切った数値表現にする
	n = string n;
	var n_len = n.length;
	var n_digits = 0;

	// 数字の数を数える
	for(var i = 0; i < n_len; i++)
	{
		var digit = n[i];
		if(digit >= '0' && digit <= '9') n_digits ++;
		else if(digit == '.' || digit == 'e') break;
	}

	var out = "";

	// カンマを挿入
	for(var i = 0; i < n_len; i++)
	{
		var digit = n[i];
		if(digit >= '0' && digit <= '9')
		{
			n_digits --;
			out += digit;
			if(n_digits > 0 && n_digits % 3 == 0)
				out += ",";
		}
		else
		{
			out += digit;
		}
	}

	return out;
}

//文字列への文字列挿入
function InsertString(str, index, insStr){
	return str.substring(0, index) + insStr + str.substring(index, str.length - index);
}

//ガイドライン描画
function DrawGideLine(layer, line, mainColor, subColor=-1, centerColor=-1)
/*
layer : 描画するレイヤ
line : 描画間隔
mainColor : 主線の色
subcolose : 副線の色(主線の中間に描画される)
centerColor : 中線の色(レイヤの縦横の中心に描画される)
*/
{
	if(line == 0) return;

	var i;
	var width = layer.width;
	var height = layer.height;

	//主線描画
	for(i=line;i<width;i+=line){
		layer.fillRect(i, 0, 1, height, mainColor);
	}
	for(i=line;i<height;i+=line){
		layer.fillRect(0, i, width, 1, mainColor);
	}

	//副線描画
	if(subColor != -1){
		for(i=line/2;i<width;i+=line){
			layer.fillRect(i, 0, 1, height, subColor);
		}
		for(i=line/2;i<height;i+=line){
			layer.fillRect(0, i, width, 1, subColor);
		}
	}

	//中線描画
	if(centerColor != -1){
		layer.fillRect(width/2, 0, 1, height, centerColor);
		layer.fillRect(0, height/2, width, 1, centerColor);
	}
}

//フラグ管理用クラス
class Flag{
	/*const*/var accuracy = 64;		//精度(ビット数)

	var _num;
	var _array = [];

	//--------------------------------------------------
	function Flag(num, param=0x00){
		create(num, param);
	}
	function finalize(){
		InvalidateArray(_array);
	}

	function create(num, param=0x00){
		_num = num;
		var i = num \ accuracy;			//配列数計算
		i += (num%accuracy==0) ? 1 : 0;	//端数がある場合は+1

		//配列を拡張
		for(;i>=0;i--){
			_array[i] = param;
		}
	}

	function clear(param=0x00){
		var i = 0;
		for(;i<_array.count;i++){
			_array[i] = param;
		}
	}

	function on(id){
		if(0 <= id && id < _num){
			_array[int(id/accuracy)] |= 1 << (int(id%accuracy));
		}
	}

	function off(id){
		if(0 <= id && id < _num){
			_array[int(id/accuracy)] &= ~(1 << (int(id%accuracy)));
		}
	}

	function check(id){
		if(0 <= id && id < _num){
			return (_array[int(id/accuracy)] & (1 << int(id%accuracy))) != 0;
		}
		return false;
	}

	function length(){
		return _num;
	}
	function object(){
		return _array;
	}
}

//パラメータ管理用クラス
class Parameter{
	var _buf = [];

	function Parameter(num){
		for(var i=0;i<num;i++){
			_buf[i] = 0;
		}
	}
	function finalize(){
		InvalidateArray(_buf);
		invalidate _buf;
	}

	function clear(id=0,num=-1){
	//numが-1の場合はid以降の全要素をクリア
		var length;
		if(num == -1){
			length = _buf.length;
		}else{
			length = id + num;
			if(length > _buf.length) length = _buf.length;
		}

		for(var i=id;i<length;i++){
			if(_buf[i] != void){
				_buf[i] = 0;
			}
		}
	}

	function get(id){
		if(0 <= id && id < _buf.length)
			return _buf[id];
	}
	function set(id, param){
		if(typeof param == "Object"){
			dm("オブジェクトはセットできません [id = "+id+"]");
			return;
		}

		if(0 <= id && id < _buf.length)
			_buf[id] = param;
	}
	function add(id, param){
		if(typeof param == "Object"){
			dm("オブジェクトはセットできません [id = "+id+"]");
			return;
		}

		if(0 <= id && id < _buf.length)
			_buf[id] += param;
	}

	function length(){
		return _buf.length;
	}
	function object(){
		return _buf;
	}
}

//点(ベクトル)を定義するクラス
class Point{
	var _x, _y, _z;

	function Point(sx=0, sy=0, sz=0){
		set(...);
	}

	function set(sx=0, sy=0, sz=0){
		if(typeof sx == "Object"){
			_x = sx.x;
			_y = sx.y;
			_z = sx.z;
		}else{
			_x = sx;
			_y = sy;
			_z = sz;
		}
	}

	function move(mx=0, my=0, mz=0){
		_x += mx;
		_y += my;
		_z += mz;
	}

	//２点間の距離
	function length(pt){
		var tx = Math.abs(_x - pt.x);
		var ty = Math.abs(_y - pt.y);
 		var tz = Math.abs(_z - pt.z);

		var temp = Math.sqrt(tx*tx + ty*ty);
		return Math.sqrt(temp*temp + tz*tz);
	}

	//単位ベクトルに変換
	function normalize(){
		var ret = new global.Point();
		var leng = length(ret);
		ret.x = _x / leng;
		ret.y = _y / leng;
		ret.z = _z / leng;
		return ret;
	}

	function toString(){
		return "%d,%d,%d".sprintf(_x, _y, _z);
	}

	property x{
		setter(v){_x = v;}
		getter(){return _x;}
	}
	property y{
		setter(v){_y = v;}
		getter(){return _y;}
	}
	property z{
		setter(v){_z = v;}
		getter(){return _z;}
	}
}

//--------------------------------------------
//アフィン変換
//angleは正で左回り(半時計回り)
//--------------------------------------------
//二次元アフィン
function D2Affine(pos, angle){
	return D3AffineZ(...);
}
//三次元アフィン Ｘ軸
function D3AffineX(pos, angle){
	var rad = (Math.PI * -angle) / 180.0;
	var sn = Math.sin(rad);
	var cs = Math.cos(rad);

	var temp = new Point();
	temp.x = pos.x;
	temp.y = pos.y * cs + pos.z * -sn;
	temp.z = pos.y * sn + pos.z * cs;
	return temp;
}
//三次元アフィン Ｙ軸
function D3AffineY(pos, angle){
	var rad = (Math.PI * -angle) / 180.0;
	var sn = Math.sin(rad);
	var cs = Math.cos(rad);

	var temp = new Point();
	temp.x = pos.x * cs + pos.z * sn;
	temp.y = pos.y;
	temp.z = pos.x * -sn + pos.z * cs;
	return temp;
}
//三次元アフィン Ｚ軸
function D3AffineZ(pos, angle){
	var rad = (Math.PI * -angle) / 180.0;
	var sn = Math.sin(rad);
	var cs = Math.cos(rad);

	var temp = new Point();
	temp.x = pos.x * cs + pos.y * -sn;
	temp.y = pos.x * sn + pos.y * cs;
	temp.z = pos.z;
	return temp;
}
//スケーリング
function D3AffineScale(pos, scale){
	var temp = new Point();
	temp.x = pos.x * scale;
	temp.y = pos.y * scale;
	temp.z = pos.z * scale;
	return temp;
}
//平行移動
function D3AffineMove(pos, mx=0, my=0, mz=0){
	var temp = new Point();
	temp.x = pos.x + mx;
	temp.y = pos.y + my;
	temp.z = pos.z + mz;
	return temp;
}
//スクリーン座標→ワールド座標
//scrnX, screnY : スクリーン座標
//scrnRange : カメラからスクリーンまでの距離
//z : カメラから点までの距離
function D3ScreenToWorld(scrnX, scrnY, scrnRange, z){
	var temp = new Point();
	var range = z + scrnRange;
	temp.x = scrnX * (range / scrnRange);
	temp.y = scrnY * (range / scrnRange);
	temp.z = z;
	return temp;
}

//矩形を表現するクラス
class Rect{
	var _top, _bottom, _left, _right;

	function Rect(sLeft=0, sTop=0, sRight=0, sBottom=0){
		set(...);
	}

	function assign(obj){
		_top = obj._top;
		_bottom = obj._bottom;
		_left = obj._left;
		_right = obj._right;
	}

	function clone(){
		var obj = new global.Rect(_left, _top, _right, _bottom);
		return obj;
	}

	function set(sLeft=0, sTop=0, sRight=0, sBottom=0){
		if(typeof sLeft == "Object"){
			_left = sLeft.left;
			_top = sLeft.top;
			_right = sLeft.right;
			_bottom = sLeft.bottom;
		}else{
			_left = sLeft;
			_right = sRight;
			if(_left > _right) _left <-> _right;

			_top = sTop;
			_bottom = sBottom;
			if(_top > _bottom) _top <-> _bottom;
		}
	}

	function clear(){
		set(0, 0, 0, 0);
	}
	function isEmpty(){
		return (width == 0 && height == 0);
	}

	function setPos(x, y){
		var w = width;
		var h = height;

		_left = x;
		_top = y;
		_right = x + w;
		_bottom = y + h;
	}

	function move(mx=0, my=0){
		_left += mx;
		_right += mx;
		_top += my;
		_bottom += my;
	}

	function scaling(scalex=1.0, scaley=1.0, cx=void, cy=void){
		var w = int(width * scalex);
		var h = int(height * scaley);

		if(cx === void){
		//中心軸
			cx = width \ 2;
			cy = height \ 2;
		}

		_left += cx;
		_top += cx;

		cx = int(cx * scalex);
		cy = int(cy * scaley);

		_left -= cx;
		_top -= cx;
		_right = _left + w;
		_bottom = _top + h;
	}

	//領域を合成する
	function add(rect*){
		var temp = new global.Rect();
		if(typeof rect[0] == "Object")
			temp.set(rect[0]);
		else
			temp.set(rect[0], rect[1], rect[2], rect[3]);

		if(isEmpty()){
			set(temp);
			return;
		}

		var l = left < temp.left?left:temp.left;
		var t = top < temp.top?top:temp.top;
		var r = right < temp.right?temp.right:right;
		var b = bottom < temp.bottom?temp.bottom:bottom;

		set(l, t, r, b);

		invalidate temp;
	}

	//領域を膨らませる
	function bulge(size=0){
		set(_left-size, _top-size, _right+size, _bottom+size);
	}

	//Rect領域同士が重なっているか
	function isOverlapRect(src){
		if(	!(_left <= src.left && src.left <= _right) &&
 			!(_left <= src.right && src.right <= _right))
			return false;
		if(	!(_top <= src.top && src.top <= _bottom) &&
 			!(_top <= src.bottom && src.bottom <= _bottom))
			return false;

		return true;
	}

	//このRect領域内に座標が収まっているか
	function isInnerPoint(x, y){
		if(	(_left <= x && x <= _right) &&
			(_top <= y && y <= _bottom))
			return true;

		return false;
	}

	//srcのRect領域がこのRect領域の内側に収まっているか
	function isInnerRect(src){
		if(!(_left <= src.left && src.right <= _right))
			return false;
		if(!(_top <= src.top && src.bottom <= _bottom))
			return false;

		return true;
	}

	//srcの線分がこのRect領域と交差しているか
	function isIntersectLine(src){
		var lines = [];
		lines[0] = new Line(_left, _top, _left+width, _top);
		lines[1] = new Line(_left, _top+height, _left+width, _top+height);
		lines[2] = new Line(_left, _top, _left, _top+height);
		lines[3] = new Line(_left+width, _top, _left+width, _top+height);
		for(var i=0;i<4;i++){
			if(lines[i].isIntersect(src)) return true;
		}
		return false;
	}

	function toString(){
		return "%d,%d,%d,%d".sprintf(_left, _top, _right, _bottom);
	}

	property top{
		setter(v){set(left, v, right, bottom);}
		getter(){return _top;}
	}
	property bottom{
		setter(v){set(left, top, right, v);}
		getter(){return _bottom;}
	}
	property left{
		setter(v){set(v, top, right, bottom);}
		getter(){return _left;}
	}
	property right{
		setter(v){set(left, top, v, bottom);}
		getter(){return _right;}
	}

	property center_x{
		getter{return (_left + _right) / 2;}
	}
	property center_y{
		getter{return (_top + _bottom) / 2;}
	}

	property width{
		getter(){return _right - _left;}
	}
	property height{
		getter(){return _bottom - _top;}
	}
}

//サイズを表現するクラス
class Size{
	var _width, _height;

	function Size(w, h){
		set(...);
	}
	function set(w, h){
		if(typeof w == "Object"){
			_width = w.width;
			_height = w.height;
		}else{
			_width = w;
			_height = h;
		}
	}

	function toString(){
		return "%d,%d".sprintf(_width, _height);
	}

	property width{
		setter(v){_width = v;}
		getter(){return _width;}
	}
	property height{
		setter(v){_height = v;}
		getter(){return _height;}
	}
}

//2次元マトリクス
// a, c
// b, d
class D2Matrix{
	var _a, _b, _c, _d;
	function D2Matrix(a=0, b=0, c=0, d=0){
		set(...);
	}
	function set(a=0, b=0, c=0, d=0){
		_a = a;
		_b = b;
		_c = c;
		_d = d;
	}

	function dot(mt){
		var ret = new global.D2Matrix();

		ret.a = _a * ret.a + _c * b;
		ret.b = _b * ret.a + _d * b;
		ret.c = _a * ret.c + _c * d;
		ret.d = _b * ret.c + _d * d;

		return ret;
	}
}

//線分を表現するクラス
class Line{
	var _x1, _y1, _x2, _y2;
	function Line(p1x=0, p1y=0, p2x=0, p2y=0){
		set(...);
	}
	function set(p1x=0, p1y=0, p2x=0, p2y=0){
		if(typeof p1x == "Object"){
			_x1 = p1x.x1;
			_y1 = p1x.y1;
			_x2 = p1x.x2;
			_y2 = p1x.y2;
		}else{
			_x1 = p1x;
			_y1 = p1y;
			_x2 = p2x;
			_y2 = p2y;
		}
	}
	function assign(obj){
		_x1 = obj.x1;
		_y1 = obj.y1;
		_x2 = obj.x2;
		_y2 = obj.y2;
	}

	function move(mx=0, my=0){
		_x1 += mx;
		_y1 += my;
		_x2 += mx;
		_y2 += my;
	}

	//線分と線分の交差判定
	function isIntersect(line){
		//直線thisと線分lineの交差判定
		var f1 = intersect(this, line);
		//直線lineと線分thisの交差判定
		var f2 = intersect(line, this);
		//両方真ならば交差している
		return (f1 && f2);
	}

	//線分と矩形の交差判定
	function isIntersectRect(rect){
		//Rectの判定を利用
		return rect.isIntersectLine(this);
	}

	//直線と線分の交差判定
	function intersect(linear, line){
		if(
			((linear.x1 - linear.x2) * (line.y1 - linear.y1) + (linear.y1 - linear.y2) * (linear.x1 - line.x1)) * 
			((linear.x1 - linear.x2) * (line.y2 - linear.y1) + (linear.y1 - linear.y2) * (linear.x1 - line.x2)) > 0){
			return false;
		}
		return true;
	}

	function toString(){
		return "%d,%d,%d,%d".sprintf(_x1, _y1, _x2, _y2);
	}

	property x1{
		setter(v){_x1 = v;}
		getter(){return _x1;}
	}
	property y1{
		setter(v){_y1 = v;}
		getter(){return _y1;}
	}
	property x2{
		setter(v){_x2 = v;}
		getter(){return _x2;}
	}
	property y2{
		setter(v){_y2 = v;}
		getter(){return _y2;}
	}
}

//１次元直線軌道を定義するクラス
class Linear{
	var _start, _end;
	var _accel;

	function Linear(start=0, end=0, accel=0){
		set(...);
	}

	function set(start=0, end=0, accel=0){
		_start = start;
		_end = end;
		_accel = accel;
	}

	function pt(t){
		if(_accel != 0){
		//加速あり
			if(_accel > 0){
			//前半加速、後半減速
				t = 1.0 - t;
				t = Math.pow(t, _accel);
				t = 1.0 - t;
			}else if(_accel < 0){
			//前半減速、後半加速
				t = Math.pow(t, -_accel);
			}
		}

		var res = (_end - _start) * t + _start;

		return res;
	}
}
//３次元直線軌道を定義するクラス
class D3Linear{
	var _start, _end;
	var _accel;

	function D3Linear(start=new Point(0,0,0), end=new Point(0,0,0), accel=0){
		_start = new Point();
		_end = new Point();
		set(...);
	}

	function set(start=new Point(0,0,0), end=new Point(0,0,0), accel=0){
		_start.set(start);
		_end.set(end);
		_accel = accel;
	}
	function finalize(){
		invalidate _start;
		invalidate _end;
	}

	function pt(t){
		var pos = new Point();

		if(_accel != 0){
		//加速あり
			if(_accel > 0){
			//前半加速、後半減速
				t = 1.0 - t;
				t = Math.pow(t, _accel);
				t = 1.0 - t;
			}else if(_accel < 0){
			//前半減速、後半加速
				t = Math.pow(t, -_accel);
			}
		}

		pos.x = (_end.x - _start.x) * t + _start.x;
		pos.y = (_end.y - _start.y) * t + _start.y;
		pos.z = (_end.z - _start.z) * t + _start.z;

		return pos;
	}
}

class LinearFrame{
	var _accel;

	var _path = [];

	function LinearFrame(path,accel=0){
		if(path !== void) set(...);
	}

	function clear(){
		_accel = 0;
		invalidate _path;
	}

	function set(path, accel=0){
		if(path.count < 6)
		{
			// 3 点以下 ( 指定するのはそのうちの2点 ) は補完できない
			throw new Exception("2 点以上を指定してください");
		}

		_path.assignStruct(path);
		_accel = accel;
	}

	function pt(t)
	{
		if(_accel != 0){
		//加速あり
			if(_accel > 0){
			//前半加速、後半減速
				t = 1.0 - t;
				t = Math.pow(t, _accel);
				t = 1.0 - t;
			}else if(_accel < 0){
			//前半減速、後半加速
				t = Math.pow(t, -_accel);
			}
		}
		if(t > 1.0) t = 1.0;

		var points = _path.count \ 3 - 1;
		var index = int (points * t) * 3;
		var pindex = index + 3;
		var bt = 100000000 \ points;
		var pt = (t*100000000 % bt) / bt;

		var x, y, z;

		var p = _path;

		if(t >= 1.0){
			x = p[p.count-3];
			y = p[p.count-2];
			z = p[p.count-1];
		}else if(t <= 0.0){
			x = p[0];
			y = p[1];
			z = p[2];
		}else{
			x = p[index  ] + (p[pindex  ] - p[index  ]) * pt;
			y = p[index+1] + (p[pindex+1] - p[index+1]) * pt;
			z = p[index+2] + (p[pindex+2] - p[index+2]) * pt;
		}

		return %[x:x, y:y, z:z];
	}
}

class Spline{
	var _accel;

	var _path = [];

	// スプライン補間
	var _zx = []; // スプラインワーク
	var _zy = []; // スプラインワーク
	var _zz = []; // スプラインワーク

	function Spline(path,accel=0){
		if(path !== void) set(...);
	}

	function clear(){
		_accel = 0;
		invalidate _path;
		_zx.clear();
		_zy.clear();
		_zz.clear();
	}

	function set(path, accel=0){
	// path = [x1,y1,z1, x2,y2,z2, x3,y3,z3, ...]
		if(path.count < 9)
		{
			// 3 点以下 ( 指定するのはそのうちの2点 ) は補完できない
			throw new Exception("2 点以上を指定してください");
		}

		_path.assignStruct(path);
		_accel = accel;

		// スプライン補間に必要なワークを計算
		var points = path.count \ 3;
		var tmpx = [], tmpy = [], tmpz = [];
		var tx = _zx, ty = _zy, tz = _zz;
		tx[0] = 0;
		ty[0] = 0;
		tz[0] = 0;
		tx[points-1] = 0;
		ty[points-1] = 0;
		tz[points-1] = 0;

		for(var i = points-2, pi = path.count-6; i >= 0; i--, pi -= 3)
		{
			tmpx[i+1] = (path[pi + 3] - path[pi  ]);
			tmpy[i+1] = (path[pi + 4] - path[pi+1]);
			tmpz[i+1] = (path[pi + 5] - path[pi+2]);
		}

		tx[1] = tmpx[2] - tmpx[1] - tx[0];
		ty[1] = tmpy[2] - tmpy[1] - ty[0];
		tz[1] = tmpz[2] - tmpz[1] - tz[0];

		tmpx[1] = 4;
		tmpy[1] = 4;
		tmpz[1] = 4;

		var lim = points - 2;
		for(var i = 1, pi = 3; i < lim; i++, pi += 3)
		{
			var x = 1 / tmpx[i];
			var y = 1 / tmpy[i];
			var z = 1 / tmpz[i];
			tx[i+1] = tmpx[i+2] - tmpx[i+1] - tmpx[i] * x;
			ty[i+1] = tmpy[i+2] - tmpy[i+1] - tmpy[i] * y;
			tz[i+1] = tmpz[i+2] - tmpz[i+1] - tmpz[i] * z;
			tmpx[i+1] = 4 - x;
			tmpy[i+1] = 4 - y;
			tmpz[i+1] = 4 - z;
		}

		tx[points-2] -= tx[points-1];
		ty[points-2] -= ty[points-1];
		tz[points-2] -= tz[points-1];

		for(var i = points-2, pi = path.count-6; i>0; i--, pi -= 3)
		{
			tx[i] = (tx[i] - tx[i+1]) / tmpx[i];
			ty[i] = (ty[i] - ty[i+1]) / tmpy[i];
			tz[i] = (tz[i] - tz[i+1]) / tmpz[i];
		}
	}

	function pt(t)
	{
		if(_accel != 0){
		//加速あり
			if(_accel > 0){
			//前半加速、後半減速
				t = 1.0 - t;
				t = Math.pow(t, _accel);
				t = 1.0 - t;
			}else if(_accel < 0){
			//前半減速、後半加速
				t = Math.pow(t, -_accel);
			}
		}
		if(t > 1.0) t = 1.0;

		var points = _path.count \ 3 - 1;
		var index = int (points * t);
		var pindex = index * 3;
		var bt = 100000000 \ points;
		var pt = (t*100000000 % bt) / bt;

		var x, y, z;

		var p = _path;

		if(t >= 1.0){
			x = p[p.count-3];
			y = p[p.count-2];
			z = p[p.count-1];
		}else if(t <= 0.0){
			x = p[0];
			y = p[1];
			z = p[2];
		}else{
			x = (((_zx[index+1] - _zx[index])*pt +
					_zx[index]*3)*pt +
					((p[pindex + 3] - p[pindex]) -
					(_zx[index]*2 + _zx[index+1]))) * pt +
					p[pindex];

			y = (((_zy[index+1] - _zy[index])*pt +
					_zy[index]*3)*pt +
					((p[pindex + 4] - p[pindex+1]) -
					(_zy[index]*2 + _zy[index+1]))) * pt +
					p[pindex+1];

			z = (((_zz[index+1] - _zz[index])*pt +
					_zz[index]*3)*pt +
					((p[pindex + 5] - p[pindex+2]) -
					(_zz[index]*2 + _zz[index+1]))) * pt +
					p[pindex+2];
		}

		return %[x:x, y:y, z:z];
	}
}

// (xxx,yyy,zzz) という文字列を数値に変換してPointクラスにして返す。
function PointStrToNum(str){
	var temp = new Point();

	var array = str.split(",/");
	switch(array.count){
	case 1:
		temp.x = int(array[0].trim());
		break;
	case 2:
		temp.x = int(array[0].trim());
		temp.y = int(array[1].trim());
		break;
	case 3:
		temp.x = int(array[0].trim());
		temp.y = int(array[1].trim());
		temp.z = int(array[2].trim());
		break;
	}

	return temp;
}
function PointStrToNumR(str){
	var temp = new Point(0.0, 0.0, 0.0);

	var array = str.split(",/");
	switch(array.count){
	case 1:
		temp.x = real(array[0].trim());
		break;
	case 2:
		temp.x = real(array[0].trim());
		temp.y = real(array[1].trim());
		break;
	case 3:
		temp.x = real(array[0].trim());
		temp.y = real(array[1].trim());
		temp.z = real(array[2].trim());
		break;
	}

	return temp;
}
//数値を(xxx,yyy,zzz) という文字列に変換する
function PointNumToStr(x=0, y=0, z=0){
	return "%d,%d,%d".sprintf(x, y, z);
}

function RectStrToNum(str){
	var temp = new Rect();

	var array = str.split(",/");
	switch(array.count){
	case 1:
		temp.set(int(array[0].trim()));
		break;
	case 2:
		temp.set(int(array[0].trim()), int(array[1].trim()));
		break;
	case 3:
		temp.set(int(array[0].trim()), int(array[1].trim()), int(array[2].trim()));
		break;
	case 4:
		temp.set(int(array[0].trim()), int(array[1].trim()), int(array[2].trim()), int(array[3].trim()));
		break;
	}

	return temp;
}
function RectNumToStr(left=0, top=0, right=0, bottom=0){
	return "%d,%d,%d,%d".sprintf(left, top, right, bottom);
}

//tgtレイヤからの相対座標を取得
//tgt=nullならプライマリレイヤからの座標、つまり絶対座標になる。
function GetAbsolutePos(layer, pos, tgt=null){
	//layerから親レイヤーを辿っていく
	if(	layer.parent != tgt && layer.parent != null)
		GetAbsolutePos(layer.parent, pos, tgt);

	//tgtレイヤを発見、またはプライマリレイヤに到達したら、
	//そこから座標を加算していく。
	pos.x += layer.left;
	pos.y += layer.top;
}

//リングバッファ
class RingBuffer{
	var _buf = [];
	var _index;
	var _init;
	var _stack;

	function RingBuffer(num=50, init=0){
		for(var i=0;i<num;i++)
			_buf[i] = init;

		_stack = 0;
		_init = init;
		_index = num - 1;
	}
	function finalize(){
		InvalidateArray(_buf);
		_buf.clear();
	}

	function clear(init){
		if(init === void) init = _init;

		for(var i=0;i<_buf.length;i++)
			_buf[i] = init;
		_index = _buf.count - 1;
		_stack = 0;
	}

	function add(elm){
		if(_stack < _buf.length) _stack++;

		_index++;
		if(_index >= _buf.length)
			_index = 0;

		_buf[_index] = elm;
	}

	function get(id=0){
		if(_stack == 0) return;

		if(id >= 0)
			id = id % _stack;
		else
			id = (id%_stack) + _stack;

		if(id <= _index){
			return _buf[_index - id];
		}else{
			return _buf[_stack - (id-_index)];
		}
	}

	property stack{
		setter(v){
			if(v >= _buf.count) _stack = _buf.count;
			else if(v < 0) _stack = 0;
			else _stack = v;
		}
		getter(){return _stack;}
	}

	function length(){
		return _buf.length;
	}

	function object(){
		return _buf;
	}
	property index{
		setter(v){
			if(_stack == 0) return;
			if(v >= _stack) _index = v % _stack;
			else if (v < 0)	_index = _stack + v;
			else			_index = v;
		}
		getter(){return _index;}
	}
}

//デバックフレームを描画する
function DrawFrame(spr, x=0, y=0, w=-1, h=-1, colBase=0x80000044, colFrame=0xff8888cc){
	var width, height;
	if(w == -1)	width = spr.width;
	else		width = w;
	if(h == -1)	height = spr.height;
	else		height = h;

	spr.colorRect(x+1, y+1, width-2, height-2, colBase&0xffffff, colBase>>24);

	spr.colorRect(x+1, y+1, width-2, 1, colFrame&0xffffff, colFrame>>24);			//横線上
	spr.colorRect(x+1, y+height-2, width-2, 1, colFrame&0xffffff, colFrame>>24);	//横線下
	spr.colorRect(x+1, y+1, 1, height-2, colFrame&0xffffff, colFrame>>24);			//縦線左
	spr.colorRect(x+width-2, y+1, 1, height-2, colFrame&0xffffff, colFrame>>24);	//縦線右

/*
	var colFrameG = colFrame&0x00ffffff;
	colFrameG |= (((colFrame&0xff000000)>>24)/2)<<24;
	spr.colorRect(x+1, y, width-2, 1, colFrameG&0xffffff, colFrameG>>24);			//横線上
	spr.colorRect(x+1, y+height-1, width-2, 1, colFrameG&0xffffff, colFrameG>>24);	//横線下
	spr.colorRect(x, y+1, 1, height-2, colFrameG&0xffffff, colFrameG>>24);			//縦線左
	spr.colorRect(x+width-1, y+1, 1, height-2, colFrameG&0xffffff, colFrameG>>24);	//縦線右
*/
}
function DrawFrameCurve(spr, x=0, y=0, w=-1, h=-1, colBase=0x80000044, colFrame=0xff8888cc, thick=2, capRound=8){
	var width, height;
	if(w == -1)	width = spr.width;
	else		width = w;
	if(h == -1)	height = spr.height;
	else		height = h;

	var app = new GdiPlus.Appearance();
	app.addBrush(colBase, 0, 0);
	app.addPen(colFrame, 
	%[
	width:thick, 
	dummy:0
	],
	 0, 0);

	x += thick/2;
	y += thick/2;
	w = width - thick;
	h = height - thick;
	var r = capRound;
	var rh = r/2;
	spr.drawBeziers(app, [
		[x+r, y], 
		[x+r, y], 
		[x+r, y], 
		[x+w-r, y], 

		[x+w-rh, y], 
		[x+w, y+rh], 
		[x+w, y+r], 

		[x+w, y+h-r], 
		[x+w, y+h-r], 
		[x+w, y+h-r], 

		[x+w, y+h-rh], 
		[x+w-rh, y+h], 
		[x+w-r, y+h], 

		[x+r, y+h],
		[x+r, y+h],
		[x+r, y+h], 

		[x+rh, y+h], 
		[x, y+h-rh], 
		[x, y+h-r], 

		[x, y+h-r], 
		[x, y+h-r], 
		[x, y+r], 

		[x, y+rh], 
		[x+rh, y], 
		[x+r, y]
	]
	);
}

//パスを解析
function PickFilename(str){
	var temp = str.split("/");
	return temp[temp.length-1];
}
function GetPath(str){
	var temp = str.split("/");
	var path = "";

	for(var i=0;i<temp.count-2;i++)
		path += temp[i] + "/";

	return path;
}
function GetFilename(str){
	var temp = str.split("/");
	return temp[temp.length-1];
}

//配列中の要素を無効化する
function InvalidateArray(array){
	for(var i=0;i<array.count;i++) invalidate array[i] if array[i] !== void;
}
//辞書配列中の要素を無効化する
function InvalidateDicArray(array){
	for(var i=0;i<array.count;i++){
		(Dictionary.clear incontextof array[i])() if array[i] !== void;
	}
}

//Aサイズに縦か横がフィットするようにBサイズを調整した値を返す
function AdjustFitSize(widthA, heightA, widthB, heightB){
	var size = new Size();

	//まず横サイズに合わせてみる
	size.width = widthA;
	size.height = heightB * (real(widthA) / widthB);

	//縦がはみ出た
	if(heightA < size.height){
		//縦サイズに合わせる
		size.width = widthB * (real(heightA) / heightB);
		size.height = heightA;
	}

	return size;
}

class TimeKeeper{
	var _startTime;	//開始時間
	var _pauseTime;	//ポーズ開始時間
	var _delay;		//遅延蓄積

	function TimeKeeper(){
		_startTime = -1;
		_pauseTime = -1;
		_delay = 0;
	}

	function start(){
		_startTime = System.getTickCount();
		_pauseTime = -1;
		_delay = 0;
	}
	function stop(){
		_startTime = -1;
		_pauseTime = -1;
		_delay = 0;
	}
	function pause(){
		if(isPause()) return;

		_pauseTime = System.getTickCount();
	}
	function restart(){
		if(!isPause()) return;

		_delay += System.getTickCount() - _pauseTime;	//遅延分を追加する
		_pauseTime = -1;
	}

	function isPause(){return _pauseTime != -1;}

	function now(){
		if(_startTime == -1) return 0;

		var now = System.getTickCount();
		var t = now - _startTime;	//総時間
		t -= _delay;		//遅延時間蓄積分を差し引く

		//現在停止中なら、その分も差し引く
		if(_pauseTime != -1) t -= now - _pauseTime;

		return t;
	}
}

//一回きりのタイマー
class OnceTimer extends Timer{
	var _owner = null;
	var _endFunc = null;
	function OnceTimer(owner, time, endFunc=null){
		super.Timer(owner, "");
		capacity = 1;
		interval = time;
		_owner = owner;
		_endFunc = endFunc;
	}

	function start(){ enabled = true; }
	function cancel(){ enabled = false; }

	function onTimer(){
		cancel();
		if(isvalid _owner) _owner();
		if(_endFunc === null || !isvalid _endFunc)
			 return;

		_endFunc(this);
	}
}
//使い捨てタイマー群管理
//一回だけ呼び出されて削除される
class DisposableTimers{
	var _list = [];
	var _cleaning;

	function DisposableTimers(){
		_cleaning = new AsyncTrigger(onCleaning, "");
		_cleaning.cached = true;
		_cleaning.mode = atmAtIdle;
	}
	function finalize(){
		InvalidateArray(_list);
	}

	function call(func, time, id=""){
		var param = %[];
		param.id = id;
		param.func = func;
		param.time = time;
		param.end = false;
		param.timer = new OnceTimer(func, time, onEnd);
		_list.add(param);

		param.timer.start();
	}
	function cancel(func){
		if(typeof func == "Object"){
			for(var i=0;i<_list.count;i++){
				if(_list[i].func == func){
					_list[i].timer.cancel();
					_list[i].end = true;
				}
			}
		}else if(func != ""){
		//funcをidとして扱う
			for(var i=0;i<_list.count;i++){
				if(_list[i].id == func){
					_list[i].timer.cancel();
					_list[i].end = true;
				}
			}
		}
		_cleaning.trigger();
	}

	function onEnd(timer){
		for(var i=0;i<_list.count;i++){
			if(_list[i].timer == timer){
				_list[i].end = true;
				break;
			}
		}
		_cleaning.trigger();
	}

	function onCleaning(){
		for(var i=_list.count-1;i>=0;i--){
			if(_list[i].end){
				invalidate _list[i].timer;
				_list.erase(i);
			}
		}
	}
}

//使い捨てタイマーの利用関数
global.DISPOSABLE_TIMERS = new DisposableTimers();
function OnceCall(func, time, id=""){
	global.DISPOSABLE_TIMERS.call(func, time, id);
}
function OnceCallCancel(func){
	global.DISPOSABLE_TIMERS.cancel(func);
}

//指定したタイミングでイベントを呼び出す。
class TimerEvent{
	var _timer;
	var _startTime;
	var _count;

	var _func = onCallback;

	//イベント定義
	//evnet = [
	//%[label:"step10", time:1000],	//1000ミリ秒後にstep10イベント発生
	//%[label:"step20", time:2000]	//2000ミリ秒後にstep20イベント発生
	//];
	var _event = [];

	function TimerEvent(event=[]){
		_timer = new Timer(callback, "");

		setEvent(event);
		init();
	}
	function finalize(){
		_timer.enabled = false;
		invalidate _timer;
		invalidate _event;
	}

	function init(){
		for(var i=0;i<_event.count;i++){
			_event[i].flag = false;
		}
	}

	function setEvent(event=[]){
		_event.assignStruct(event);
	}

	function start(func, count=1, interval = 50){
		init();

		_func = func;

		_count = count;

		_timer.interval = interval;
		_timer.enabled = true;

		_startTime = System.getTickCount();
	}
	function stop(){
		if(_timer.enabled){
			_timer.enabled = false;
			_func("TimerEvent-end", -1, 0, void, false);
		}
	}

	function callback(){
		var now = System.getTickCount() - _startTime;
		for(var i=0;i<_event.count;i++){
			if(!_event[i].flag){
				if(_event[i].time < now){
					_func(_event[i].label, _event[i].id, now - _event[i].time, _event[i], false);
					_event[i].flag = true;
				}
			}
		}
		if(isEnd()){
			_count--;
			if(_count < 0 || _count > 0){
				init();
				start(_func, _count, _timer.interval);
			}else{
				stop();
			}
		}
	}

	function flush(){
		for(var i=0;i<_event.count;i++){
			if(!_event[i].flag){
				_func(_event[i].label, _event[i].id, 0, _event[i], true);
				_event[i].flag = true;
			}
		}
		stop();
	}

	function isEnd(){
		for(var i=0;i<_event.count;i++){
			if(!_event[i].flag) return false;
		}
		return true;
	}

	function onCallback(label, id, delay, elm, flush=false){
	}

	property startTime{
		getter(){return _startTime;}
	}

	property event{
		getter(){return _event;}
	}
}

//タイルコピー
//コピー先のdy, dy, dwidth, dheightの領域に
//コピー元のdy, dy, dwidth, dheightの領域をタイル状にコピー
function TileCopyRect(dst, dx, dy, dwidth, dheight, src, sx, sy, swidth, sheight){
	var xcount = dwidth \ swidth;
	var xrest = dwidth % swidth;
	var ycount = dheight \ sheight;
	var yrest = dheight % sheight;

	var copyWidth  = swidth;
	if(copyWidth > dwidth)
		copyWidth = dwidth;
	var copyHeight = sheight;
	if(copyWidth > dwidth)
		copyHeight = dheight;

	var iy, ix;
	for(iy=0;iy<ycount;iy++){
		for(ix=0;ix<xcount;ix++){
			dst.copyRect(dx+copyWidth*ix, dy+copyHeight*iy, src, sx, sy, copyWidth, copyHeight);
		}
		if(xrest){
			dst.copyRect(dx+copyWidth*ix, dy+copyHeight*iy, src, sx, sy, xrest, copyHeight);
		}
	}
	if(yrest){
		for(ix=0;ix<xcount;ix++){
			dst.copyRect(dx+copyWidth*ix, dy+copyHeight*iy, src, sx, sy, copyWidth, yrest);
		}
		if(xrest){
			dst.copyRect(dx+copyWidth*ix, dy+copyHeight*iy, src, sx, sy, xrest, yrest);
		}
	}
}

//パスの追加
function AddAutoPath(name){
	//">"で分割
	var path = name.split(">");

	if(path.count == 1){
		//分割できなかったので普通に追加
		Storages.addAutoPath(name);
		return true;
	}else{
	//分割出来た場合は、アーカイブファイルの有無をチェックしてから追加
		if(Storages.isExistentStorage(System.exePath + path[0])) {
		//見つかった
			Storages.addAutoPath(System.exePath + name);
			return true;
		}
	}
	return false;
}
//スクリプト読み込み
function LoadScript(name){
	if(Storages.isExistentStorage(name)){
		Scripts.execStorage(name);
	}else{
		dm(name+"が見つかりませんでした。");
	}
}

//args[0]を返す
function GetElm(args*){
	if(args.count == 2)
	//args[0]がvoidならargs[1]を返す
		return args[0] !== void ? args[0] : args[1];
	else if(args.count == 3)
	//args[0]がvoid以外ならargs[1], voidならarg[2]を返す
		return args[0] !== void ? args[1] : args[2];
	return void;
}

//イメージのファイルサイズを返す
function GetImageFileSize(img){
	return img.imageWidth * img.imageHeight * 4 + 54;
}

//度数をラジアンに変換
function DegToRad(deg){
	return (Math.PI * deg) / 180.0;
}

function foreach(list=[], func){
	for(var i=0;i<list.count;i++){
		func(list[i]);
	}
}

//上限下限処理
function ULimit(src, upper){
	if(src > upper) return upper;
	return src;
}
function DLimit(src, lower){
	if(src < lower) return lower;
	return src;
}
function UDLimit(src, upper, lower){
	if(src > upper) return upper;
	if(src < lower) return lower;
	return src;
}
